<!DOCTYPE html>
<!-- saved from url=(0090)#http%E8%B6%85%E6%97%B6timeout%E9%85%8D%E7%BD%AE -->
<html lang="en" class="js dark-theme"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="SPRINGDOC.CN 提供最新的Spring Boot, Spring Cloud, Spring Security等Spring框架的官方中文文档。">
<meta name="keywords" content="spring 中文文档, spring cloud 中文文档, spring boot 中文文档, spring security 中文文档, spring 官方文档">
<title>Spring Cloud Gateway 中文文档</title>
<link rel="stylesheet" href="./Spring Cloud Gateway 中文文档_files/site.css">
<script src="./Spring Cloud Gateway 中文文档_files/hm.js.下载"></script><script src="./Spring Cloud Gateway 中文文档_files/setup.js.下载"></script><script defer="" src="./Spring Cloud Gateway 中文文档_files/site.js.下载"></script>

</head>
<body class="book toc2 toc-left fixed-toc"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox">
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Spring Cloud Gateway 中文文档</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1 expanded">
<li class=""><a href="#gateway-starter">1. 如何添加 Spring Cloud Gateway</a></li>
<li class=""><a href="#%E6%9C%AF%E8%AF%AD%E8%A1%A8">2. 术语表</a></li>
<li class=""><a href="#gateway-how-it-works">3. 它是如何工作的</a></li>
<li class=""><a href="#%E9%85%8D%E7%BD%AEroute-predicate-filter-%E5%B7%A5%E5%8E%82">4. 配置Route ，Predicate ，Filter 工厂</a>
<ul class="sectlevel2">
<li class=""><a href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE">4.1. 快捷方式的配置</a></li>
<li class=""><a href="#%E5%AE%8C%E5%85%A8%E5%B1%95%E5%BC%80%E7%9A%84%E5%8F%82%E6%95%B0">4.2. 完全展开的参数</a></li>
</ul>
</li>
<li class=""><a href="#gateway-request-predicates-factories">5. Route Predicate（路由谓词）工厂</a>
<ul class="sectlevel2">
<li class=""><a href="#after">5.1. After</a></li>
<li class=""><a href="#before">5.2. Before</a></li>
<li class=""><a href="#between">5.3. Between</a></li>
<li class=""><a href="#cookie">5.4. Cookie</a></li>
<li class=""><a href="#header">5.5. Header</a></li>
<li class=""><a href="#host">5.6. Host</a></li>
<li class=""><a href="#method">5.7. Method</a></li>
<li class=""><a href="#path">5.8. Path</a></li>
<li class=""><a href="#query">5.9. Query</a></li>
<li class=""><a href="#remoteaddr">5.10. RemoteAddr</a>
<ul class="sectlevel3">
<li class=""><a href="#%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E5%9C%B0%E5%9D%80remote-addresse%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F">5.10.1. 修改远程地址（Remote Addresse）的解析方式</a></li>
</ul>
</li>
<li class=""><a href="#weight">5.11. Weight</a></li>
<li class=""><a href="#xforwarded-remote-addr">5.12. XForwarded Remote Addr</a></li>
</ul>
</li>
<li class=""><a href="#gatewayfilter-%E5%B7%A5%E5%8E%82">6. <code>GatewayFilter</code> 工厂</a>
<ul class="sectlevel2">
<li class=""><a href="#addrequestheader">6.1. <code>AddRequestHeader</code></a></li>
<li class=""><a href="#addrequestheadersifnotpresent">6.2. <code>AddRequestHeadersIfNotPresent</code></a></li>
<li class=""><a href="#addrequestparameter">6.3. <code>AddRequestParameter</code></a></li>
<li class=""><a href="#addresponseheader">6.4. <code>AddResponseHeader</code></a></li>
<li class=""><a href="#spring-cloud-circuitbreaker-filter-factory">6.5. <code>CircuitBreaker</code></a>
<ul class="sectlevel3">
<li><a href="#circuit-breaker-status-codes">6.5.1. 熔断指定的状态码</a></li>
</ul>
</li>
<li class=""><a href="#cacherequestbody">6.6. <code>CacheRequestBody</code></a></li>
<li><a href="#deduperesponseheader">6.7. <code>DedupeResponseHeader</code></a></li>
<li class=""><a href="#fallback-headers">6.8. <code>FallbackHeaders</code></a></li>
<li class=""><a href="#jsontogrpc">6.9. <code>JsonToGrpc</code></a></li>
<li><a href="#localresponsecache">6.10. <code>LocalResponseCache</code></a></li>
<li><a href="#maprequestheader">6.11. <code>MapRequestHeader</code></a></li>
<li class=""><a href="#modifyrequestbody">6.12. <code>ModifyRequestBody</code></a></li>
<li class=""><a href="#modifyresponsebody">6.13. <code>ModifyResponseBody</code></a></li>
<li><a href="#prefixpath">6.14. <code>PrefixPath</code></a></li>
<li class=""><a href="#preservehostheader">6.15. <code>PreserveHostHeader</code></a></li>
<li class=""><a href="#redirectto">6.16. <code>RedirectTo</code></a></li>
<li class=""><a href="#removejsonattributesresponsebody">6.17. <code>RemoveJsonAttributesResponseBody</code></a></li>
<li class=""><a href="#removerequestheader">6.18. <code>RemoveRequestHeader</code></a></li>
<li class=""><a href="#removerequestparameter">6.19. <code>RemoveRequestParameter</code></a></li>
<li><a href="#removeresponseheader">6.20. <code>RemoveResponseHeader</code></a></li>
<li class=""><a href="#requestheadersize">6.21. <code>RequestHeaderSize</code></a></li>
<li class=""><a href="#requestratelimiter">6.22. <code>RequestRateLimiter</code></a>
<ul class="sectlevel3">
<li class=""><a href="#redis-ratelimiter">6.22.1. Redis <code>RateLimiter</code></a></li>
</ul>
</li>
<li class=""><a href="#rewritelocationresponseheader">6.23. <code>RewriteLocationResponseHeader</code></a></li>
<li><a href="#rewritepath">6.24. <code>RewritePath</code></a></li>
<li class=""><a href="#rewriteresponseheader">6.25. <code>RewriteResponseHeader</code></a></li>
<li><a href="#savesession">6.26. <code>SaveSession</code></a></li>
<li class=""><a href="#secureheaders">6.27. <code>SecureHeaders</code></a></li>
<li><a href="#setpath">6.28. <code>SetPath</code></a></li>
<li class=""><a href="#setrequestheader">6.29. <code>SetRequestHeader</code></a></li>
<li><a href="#setresponseheader">6.30. <code>SetResponseHeader</code></a></li>
<li><a href="#setstatus">6.31. <code>SetStatus</code></a></li>
<li><a href="#stripprefix">6.32. <code>StripPrefix</code></a></li>
<li class=""><a href="#retry">6.33. <code>Retry</code></a></li>
<li class=""><a href="#requestsize">6.34. <code>RequestSize</code></a></li>
<li><a href="#setrequesthostheader">6.35. <code>SetRequestHostHeader</code></a></li>
<li class=""><a href="#tokenrelay">6.36. <code>TokenRelay</code></a></li>
<li class=""><a href="#%E9%BB%98%E8%AE%A4-filter">6.37. 默认 Filter</a></li>
</ul>
</li>
<li class=""><a href="#%E5%85%A8%E5%B1%80-filter">7. 全局 Filter</a>
<ul class="sectlevel2">
<li class=""><a href="#gateway-combined-global-filter-and-gatewayfilter-ordering">7.1. <code>GlobalFilter</code> 组合和 <code>GatewayFilter</code> 的顺序</a></li>
<li class=""><a href="#gateway-metrics%E6%8C%87%E6%A0%87-filter">7.2. Gateway Metrics（指标） Filter</a></li>
<li><a href="#local-cache-response-global-filter">7.3. Local Response Cache Filter</a></li>
<li><a href="#forward-routing-filter">7.4. Forward Routing Filter</a></li>
<li><a href="#netty-routing-filter">7.5. Netty Routing Filter</a></li>
<li><a href="#netty-write-response-filter">7.6. Netty Write Response Filter</a></li>
<li><a href="#reactive-loadbalancer-client-filter">7.7. <code>ReactiveLoadBalancerClientFilter</code></a></li>
<li><a href="#routetorequesturl-filter">7.8. <code>RouteToRequestUrl</code> Filter</a></li>
<li class=""><a href="#websocket-routing-filter">7.9. Websocket Routing Filter</a></li>
<li><a href="#%E6%A0%87%E8%AE%B0-exchange-%E4%B8%BA%E5%B7%B2%E8%B7%AF%E7%94%B1">7.10. 标记 exchange 为已路由</a></li>
</ul>
</li>
<li class=""><a href="#httpheadersfilter">8. HttpHeadersFilter</a>
<ul class="sectlevel2">
<li class=""><a href="#forwarded-headers-filter">8.1. Forwarded Headers Filter</a></li>
<li><a href="#removehopbyhop-headers-filter">8.2. RemoveHopByHop Headers Filter</a></li>
<li><a href="#xforwarded-headers-filter">8.3. XForwarded Headers Filter</a></li>
</ul>
</li>
<li class=""><a href="#tls-%E5%92%8C-ssl">9. TLS 和 SSL</a>
<ul class="sectlevel2">
<li><a href="#tls-%E6%8F%A1%E6%89%8B">9.1. TLS 握手</a></li>
</ul>
</li>
<li class=""><a href="#%E9%85%8D%E7%BD%AEconfiguration">10. 配置（Configuration）</a>
<ul class="sectlevel2">
<li class=""><a href="#routedefinition-%E6%8C%87%E6%A0%87">10.1. RouteDefinition 指标</a></li>
</ul>
</li>
<li class="active"><a href="#%E8%B7%AF%E7%94%B1%E5%85%83%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE">11. 路由元数据配置</a></li>
<li class=""><a href="#http%E8%B6%85%E6%97%B6timeout%E9%85%8D%E7%BD%AE">12. Http超时（timeout）配置</a>
<ul class="sectlevel2">
<li class=""><a href="#%E5%85%A8%E5%B1%80-timeout">12.1. 全局 timeout</a></li>
<li class=""><a href="#%E6%AF%8F%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84-timeout">12.2. 每个路由的 timeout</a></li>
<li class=""><a href="#route-%E7%9A%84fluent%E5%BC%8F-java-api">12.3. Route 的Fluent式 Java API</a></li>
<li><a href="#discoveryclient-%E8%B7%AF%E7%94%B1%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0">12.4. <code>DiscoveryClient</code> 路由服务的注册与发现</a>
<ul class="sectlevel3">
<li><a href="#%E4%B8%BA-discoveryclient-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E8%B0%93%E8%AF%8D%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8">12.4.1. 为 <code>DiscoveryClient</code> 路由配置谓词和过滤器</a></li>
</ul>
</li>
</ul>
</li>
<li class=""><a href="#reactor-netty-%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97">13. Reactor Netty 访问日志</a></li>
<li class=""><a href="#cors-%E9%85%8D%E7%BD%AE">14. CORS 配置</a>
<ul class="sectlevel2">
<li><a href="#global-cors-%E9%85%8D%E7%BD%AE">14.1. Global CORS 配置</a></li>
<li class=""><a href="#%E8%B7%AF%E7%94%B1%E7%9A%84-cors-%E9%85%8D%E7%BD%AE">14.2. 路由的 CORS 配置</a></li>
</ul>
</li>
<li class=""><a href="#actuator-api">15. Actuator API</a>
<ul class="sectlevel2">
<li class=""><a href="#%E5%86%97%E9%95%BF%E7%9A%84-actuator-%E6%A0%BC%E5%BC%8F">15.1. 冗长的 Actuator 格式</a></li>
<li><a href="#%E6%A3%80%E7%B4%A2%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8">15.2. 检索路由过滤器</a>
<ul class="sectlevel3">
<li><a href="#gateway-global-filters">15.2.1. 全局过滤器（Global Filter）</a></li>
<li><a href="#gateway-route-filters">15.2.2. 路由过滤器（Route Filter）</a></li>
</ul>
</li>
<li class=""><a href="#%E5%88%B7%E6%96%B0%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98">15.3. 刷新路由缓存</a></li>
<li class=""><a href="#%E6%A3%80%E7%B4%A2%E7%BD%91%E5%85%B3%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B7%AF%E7%94%B1">15.4. 检索网关中自定义的路由</a></li>
<li class=""><a href="#gateway-retrieving-information-about-a-particular-route">15.5. 检索指定的路由</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E7%94%B1">15.6. 创建和删除一个指定的路由</a></li>
<li><a href="#%E5%9B%9E%E9%A1%BE%E6%89%80%E6%9C%89%E7%AB%AF%E7%82%B9%E5%88%97%E8%A1%A8">15.7. 回顾：所有端点列表</a></li>
<li class=""><a href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%BD%91%E5%85%B3%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E8%B7%AF%E7%94%B1">15.8. 在多个网关实例之间共享路由</a></li>
</ul>
</li>
<li class=""><a href="#troubleshooting">16. 问题排查</a>
<ul class="sectlevel2">
<li class=""><a href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">16.1. 日志级别</a></li>
<li class=""><a href="#wiretap">16.2. Wiretap</a></li>
</ul>
</li>
<li class=""><a href="#%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C">17. 开发手册</a>
<ul class="sectlevel2">
<li><a href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1route%E8%B0%93%E8%AF%ADpredicate%E5%B7%A5%E5%8E%82">17.1. 编写自定义路由（Route）谓语（Predicate）工厂</a></li>
<li class=""><a href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89-gatewayfilter-%E5%B7%A5%E5%8E%82">17.2. 编写自定义 GatewayFilter 工厂</a>
<ul class="sectlevel3">
<li class=""><a href="#%E5%9C%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%91%BD%E5%90%8D%E8%87%AA%E5%AE%9A%E4%B9%89-filter-%E5%92%8C%E5%BC%95%E7%94%A8">17.2.1. 在配置中命名自定义 Filter 和引用</a></li>
</ul>
</li>
<li class=""><a href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8">17.3. 编写自定义全局过滤器</a></li>
</ul>
</li>
<li class=""><a href="#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8spring-mvc%E6%88%96webflux%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E5%85%B3">18. 通过使用Spring MVC或Webflux构建一个简单的网关</a></li>
<li class=""><a href="#aot-%E5%92%8C-%E5%8E%9F%E7%94%9F%E9%95%9C%E5%83%8Fnative-image%E7%9A%84%E6%94%AF%E6%8C%81">19. AOT 和 原生镜像（Native Image）的支持</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7">20. 配置属性</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
本站(<a href="https://springdoc.cn/">springdoc.cn</a>)中的内容来源于 <a href="https://spring.io/">spring.io</a> ，原始版权归属于 <a href="https://spring.io/">spring.io</a>。由 <a href="https://springdoc.cn/">springdoc.cn</a> 进行翻译，整理。可供个人学习、研究，未经许可，不得进行任何转载、商用或与之相关的行为。 商标声明：Spring 是 Pivotal Software, Inc. 在美国以及其他国家的商标。
</td>
</tr>
</tbody></table>
</div>
<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b2a81b03c7f4f9f9c62ec0e07502fe0d";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<script defer="" src="./Spring Cloud Gateway 中文文档_files/home.js.下载"></script>
<div class="paragraph">
<p><strong>4.0.2-SNAPSHOT</strong></p>
</div>
<div class="paragraph">
<p>这个项目提供了一个建立在Spring生态系统之上的API网关，包括。Spring 6、Spring Boot 3 和Project Reactor。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为其提供跨领域的关注，如：安全、监控/指标和容错。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="gateway-starter"><a class="anchor" href="#gateway-starter"></a><a class="link" href="#gateway-starter">1. 如何添加 Spring Cloud Gateway</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>要在你的项目中添加 Spring Cloud Gateway，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-gateway</code> 的starter。请参阅 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud项目页面</a>，了解使用当前 Spring Cloud Release Train 设置构建系统的详情。</p>
</div>
<div class="paragraph">
<p>如果你添加了 starter，但你不希望启用网关，请设置 <code>spring.cloud.gateway.enabled=false</code>。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Spring Cloud Gateway 是建立在 <a href="https://spring.io/projects/spring-boot#learn">Spring Boot 2.x</a>、 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">Spring WebFlux</a> 和 <a href="https://projectreactor.io/docs">Project Reactor</a>之上。因此，你所熟悉的许多同步库（例如Spring Data和Spring Security）和模式在你使用Spring Cloud Gateway时可能不适用。如果你不熟悉这些项目，我们建议你在使用Spring Cloud Gateway之前，先阅读它们的文档，熟悉一些新概念。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行时。它不能在传统的Servlet容器中工作，也不能以WAR的形式构建。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="术语表"><a class="anchor" href="#%E6%9C%AF%E8%AF%AD%E8%A1%A8"></a><a class="link" href="#%E6%9C%AF%E8%AF%AD%E8%A1%A8">2. 术语表</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Route（路由）</strong>: 网关的基本构件。它由一个ID、一个目的地URI、一个谓词（Predicate）集合和一个过滤器（Filter）集合定义。如果集合谓词为真，则路由被匹配。</p>
</li>
<li>
<p><strong>Predicate（谓词）</strong>: 这是一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">Java 8 Function Predicate</a>。输入类型是 <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html">Spring Framework <code>ServerWebExchange</code></a>。这让你可以在HTTP请求中的任何内容上进行匹配，比如header或查询参数。</p>
</li>
<li>
<p><strong>Filter（过滤器）</strong>: 这些是 <a href="https://github.com/spring-cloud/spring-cloud-gateway/tree/main/spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/GatewayFilter.java"><code>GatewayFilter</code></a> 的实例，已经用特定工厂构建。在这里，你可以在发送下游请求之前或之后修改请求和响应。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="gateway-how-it-works"><a class="anchor" href="#gateway-how-it-works"></a><a class="link" href="#gateway-how-it-works">3. 它是如何工作的</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>下图提供了一个关于 Spring Cloud Gateway 如何工作的高层次概述。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Gateway 中文文档_files/spring_cloud_gateway_diagram.png" alt="Spring Cloud Gateway Diagram">
</div>
</div>
<div class="paragraph">
<p>客户端向 Spring Cloud Gateway 发出请求。如果Gateway处理程序映射确定一个请求与路由相匹配，它将被发送到Gateway Web处理程序。这个处理程序通过一个特定于该请求的过滤器链来运行该请求。过滤器被虚线分割的原因是，过滤器可以在代理请求发送之前和之后运行逻辑。所有的 <code>"pre"</code> （前）过滤器逻辑都被执行。然后发出代理请求。在代理请求发出后，<code>"post"</code> （后）过滤器逻辑被运行。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在路由中定义的没有端口的URI，其HTTP和HTTPS URI的默认端口值分别为80和443。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="配置route-predicate-filter-工厂"><a class="anchor" href="#%E9%85%8D%E7%BD%AEroute-predicate-filter-%E5%B7%A5%E5%8E%82"></a><a class="link" href="#%E9%85%8D%E7%BD%AEroute-predicate-filter-%E5%B7%A5%E5%8E%82">4. 配置Route ，Predicate ，Filter 工厂</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>有两种方式来配置谓词和过滤器：快捷方式和完全展开的参数。下面的大多数例子都使用快捷方式。</p>
</div>
<div class="paragraph">
<p>名称和参数名称作为 <code>code</code> 列在每一节的第一或第二句中。参数通常按照快捷方式配置所需的顺序列出。</p>
</div>
<div class="sect2">
<h3 id="快捷方式的配置"><a class="anchor" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE"></a><a class="link" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE">4.1. 快捷方式的配置</a></h3>
<div class="paragraph">
<p>快捷方式配置由过滤器名称（filter name），后面跟一个等号 (<code>=</code>)，然后是用逗号 (<code>,</code>) 分隔的参数值。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=mycookie,mycookievalue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>上面的例子定义了 <code>Cookie</code> 路由谓词工厂，有两个参数，cookie 名称， <code>mycookie</code> 和与 <code>mycookievalue</code> 匹配的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="完全展开的参数"><a class="anchor" href="#%E5%AE%8C%E5%85%A8%E5%B1%95%E5%BC%80%E7%9A%84%E5%8F%82%E6%95%B0"></a><a class="link" href="#%E5%AE%8C%E5%85%A8%E5%B1%95%E5%BC%80%E7%9A%84%E5%8F%82%E6%95%B0">4.2. 完全展开的参数</a></h3>
<div class="paragraph">
<p>完全展开的参数看起来更像标准的yaml配置，有名称/值对。一般来说，会有一个 <code>name</code> key和一个 <code>args</code> key。<code>args</code> key是一个键值对的映射，用于配置谓词或过滤器。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cookie</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">mycookie</span>
            <span class="hljs-attr">regexp:</span> <span class="hljs-string">mycookievalue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>这就是上面所示的 <code>Cookie</code> 谓词的快捷配置的完整配置。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="gateway-request-predicates-factories"><a class="anchor" href="#gateway-request-predicates-factories"></a><a class="link" href="#gateway-request-predicates-factories">5. Route Predicate（路由谓词）工厂</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Gateway将路由匹配作为Spring WebFlux <code>HandlerMapping</code> 基础设施的一部分。Spring Cloud Gateway包括许多内置的路由谓词工厂。所有这些谓词都与HTTP请求的不同属性相匹配。你可以用逻辑 <code>and</code> 语句组合多个路由谓词工厂。</p>
</div>
<div class="sect2">
<h3 id="after"><a class="anchor" href="#after"></a><a class="link" href="#after">5.1. After</a></h3>
<div class="paragraph">
<p><code>After</code> 路由谓词工厂需要一个参数，即一个日期时间（这是一个java <code>ZonedDateTime</code>）。这个谓词匹配发生在指定日期时间之后的请求。下面的例子配置了一个After路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该路由与北美山区时间（丹佛）2017年1月20日17:42之后发出的任何请求相匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="before"><a class="anchor" href="#before"></a><a class="link" href="#before">5.2. Before</a></h3>
<div class="paragraph">
<p><code>Before</code> 路由谓词工厂只需要一个参数，即 <code>datetime</code>（这是一个java <code>ZonedDateTime</code>）。这个谓词匹配发生在指定 <code>datetime</code> 之前的请求。下面的例子配置了一个Before路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">before_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该路由与北美山区时间2017年1月20日17:42（丹佛）之前发出的任何请求相匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="between"><a class="anchor" href="#between"></a><a class="link" href="#between">5.3. Between</a></h3>
<div class="paragraph">
<p><code>Between</code> 路由谓词工厂需要两个参数，<code>datetime1</code> 和 <code>datetime2</code>，它们是java  <code>ZonedDateTime</code> 对象。这个谓词匹配发生在 <code>datetime1</code> 之后和 <code>datetime2</code> 之前的请求。<code>datetime2</code> 的参数必须在 <code>datetime1</code> 之后。下面的例子配置了一个 between 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">between_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="hljs-number">2017-01-21T17:42:47.789-07:00</span>[<span class="hljs-string">America/Denver</span>]</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个路由匹配2017年1月20日山区时间（丹佛）17:42之后和2017年1月21日山区时间（丹佛）17:42之前的任何请求。这对维护窗口可能是有用的。</p>
</div>
</div>
<div class="sect2">
<h3 id="cookie"><a class="anchor" href="#cookie"></a><a class="link" href="#cookie">5.4. Cookie</a></h3>
<div class="paragraph">
<p><code>Cookie</code> 路由谓词工厂接受两个参数，即 cookie <code>name</code> 和一个 <code>regexp</code>（这是一个Java正则表达式）。这个谓词匹配具有给定名称且其值符合正则表达式的cookie。下面的例子配置了一个cookie路由谓词工厂。</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cookie_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=chocolate,</span> <span class="hljs-string">ch.p</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个路由匹配有一个名为 <code>chocolate</code> 的cookie，其值符合 <code>ch.p</code> 正则表达式的请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="header"><a class="anchor" href="#header"></a><a class="link" href="#header">5.5. Header</a></h3>
<div class="paragraph">
<p><code>Header</code> 路由谓词工厂需要两个参数，<code>header</code> 和一个 <code>regexp</code>（这是一个Java正则表达式）。这个谓词与具有给定名称且其值与正则表达式相匹配的 header 匹配。下面的例子配置了一个 header 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,</span> <span class="hljs-string">\d+</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果请求有一个名为 <code>X-Request-Id</code> 的header，其值与 <code>\d+</code> 正则表达式相匹配（也就是说，它的值是一个或多个数字），则该路由匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="host"><a class="anchor" href="#host"></a><a class="link" href="#host">5.6. Host</a></h3>
<div class="paragraph">
<p><code>Host</code> 路由谓语工厂接受一个参数：一个主机（Host）名称的 <code>patterns</code> 列表。该pattern是Ant风格的模式，以 <code>.</code> 为分隔符。这个谓词匹配符合该pattern的Host header。下面的例子配置了一个 host 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">host_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Host=**.somehost.org,**.anotherhost.org</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>支持URI模板变量（如 <code>{sub}.myhost.org</code>）。</p>
</div>
<div class="paragraph">
<p>如果请求的 <code>Host</code> header的值为 <code>www.somehost.org</code> 或 <code>beta.somehost.org</code> 或 <code>www.anotherhost.org</code>，则该路由匹配。</p>
</div>
<div class="paragraph">
<p>这个谓词提取URI模板变量（比如前面例子中定义的 <code>sub</code>）作为名称和值的映射，并将其放在 <code>ServerWebExchange.getAttributes()</code> 中，key值定义在 <code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>。然后这些值就可以被 <a href="#gateway-route-filters"><code>GatewayFilter</code> 工厂</a>使用了。</p>
</div>
</div>
<div class="sect2">
<h3 id="method"><a class="anchor" href="#method"></a><a class="link" href="#method">5.7. Method</a></h3>
<div class="paragraph">
<p><code>Method</code> 路由谓词工厂接受一个 <code>methods</code> 参数，它是一个或多个参数：要匹配的HTTP方法。下面的例子配置了一个 method 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">method_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Method=GET,POST</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果请求方式是 <code>GET</code> 或 <code>POST</code>，则该路由匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="path"><a class="anchor" href="#path"></a><a class="link" href="#path">5.8. Path</a></h3>
<div class="paragraph">
<p><code>Path</code> 路由谓词工厂需要两个参数：一个Spring <code>PathMatcher</code> <code>patterns</code> 的list和一个可选的flag <code>matchTrailingSlash</code>（默认为 <code>true</code>）。下面的例子配置了一个path路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/red/{segment},/blue/{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果请求路径是 <code>/red/1</code> 或 <code>/red/1/</code> 或 <code>/red/blue</code> 或 <code>/blue/green</code>，则该路由匹配。</p>
</div>
<div class="paragraph">
<p>如果 <code>matchTrailingSlash</code> 被设置为 <code>false</code>，那么请求路径 <code>/red/1/</code> 将不会被匹配。</p>
</div>
<div class="paragraph">
<p>这个谓词提取URI模板变量（比如前面例子中定义的 <code>segment</code>）作为name和value的映射，并把它放在 <code>ServerWebExchange.getAttributes()</code> 中，KEY值定义在 <code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>。然后这些值就可以被 <a href="#gateway-route-filters"><code>GatewayFilter</code> 工厂</a>使用了。</p>
</div>
<div class="paragraph">
<p>有一个实用的方法（称为 <code>get</code>），可以使访问这些变量变得更容易。下面的例子显示了如何使用 <code>get</code> 方法。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, String&gt; uriVariables = ServerWebExchangeUtils.getUriTemplateVariables(exchange);

String segment = uriVariables.get(<span class="hljs-string">"segment"</span>);
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query"><a class="anchor" href="#query"></a><a class="link" href="#query">5.9. Query</a></h3>
<div class="paragraph">
<p><code>Query</code> 路由谓词工厂需要两个参数：一个必需的 <code>param</code> 和一个可选的 <code>regexp</code>（这是一个Java正则表达式）。下面的例子配置了一个 query 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">query_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Query=green</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果请求包含一个 <code>green</code> 的查询参数，前面的路由就会匹配。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">query_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Query=red,</span> <span class="hljs-string">gree.</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求中包含一个 <code>red</code> 的查询参数，其值与 <code>gree.</code> 表达式相匹配，那么路由就会匹配。例如： <code>green</code> 和 <code>greet</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="remoteaddr"><a class="anchor" href="#remoteaddr"></a><a class="link" href="#remoteaddr">5.10. RemoteAddr</a></h3>
<div class="paragraph">
<p><code>RemoteAddr</code> 路由谓词工厂接受一个 <code>sources</code> 集合（最小长度为1），它是CIDR注解（IPv4或IPv6）字符串，如 <code>192.168.0.1/16</code>（其中 <code>192.168.0.1</code> 是一个IP地址，<code>16</code> 是一个子网掩码）。下面的例子配置了一个RemoteAddr路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">remoteaddr_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoteAddr=192.168.1.1/24</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果请求的远程地址 <code>192.168.1.10</code>，则该路由匹配。</p>
</div>
<div class="sect3">
<h4 id="修改远程地址remote-addresse的解析方式"><a class="anchor" href="#%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E5%9C%B0%E5%9D%80remote-addresse%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F"></a><a class="link" href="#%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E5%9C%B0%E5%9D%80remote-addresse%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F">5.10.1. 修改远程地址（Remote Addresse）的解析方式</a></h4>
<div class="paragraph">
<p>默认情况下，RemoteAddr路由谓语工厂使用传入请求中的远程地址。如果Spring Cloud Gateway位于代理层后面，这可能与实际的客户IP地址不一致。</p>
</div>
<div class="paragraph">
<p>你可以通过设置一个自定义的 <code>RemoteAddressResolver</code> 来定制远程地址的解析方式。Spring Cloud Gateway有一个非默认的远程地址解析器，它是基于 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For">X-Forwarded-For Header</a>的，即 <code>XForwardedRemoteAddressResolver</code>。</p>
</div>
<div class="paragraph">
<p><code>XForwardedRemoteAddressResolver</code> 有两个静态构造方法，它们对安全问题采取了不同的方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>XForwardedRemoteAddressResolver::trustAll</code> 返回一个 <code>RemoteAddressResolver</code>，它总是采用 <code>X-Forwarded-For</code> 头中发现的第一个IP地址。这种方法容易受到欺骗，因为恶意的客户端可以为 <code>X-Forwarded-For</code> 设置一个初始值，这将被解析器所接受。</p>
</li>
<li>
<p><code>XForwardedRemoteAddressResolver::maxTrustedIndex</code> 需要一个索引，该索引与在 Spring Cloud Gateway 前面运行的可信基础设施的数量相关。例如，如果 Spring Cloud Gateway 只能通过 HAProxy 访问，那么应使用1的值。如果在Spring Cloud Gateway被访问之前需要经过2个受信任的基础设施，那么应该使用2的值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请考虑以下 header 值。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="hljs http"><span class="hljs-attribute">X-Forwarded-For</span><span class="hljs-punctuation">: </span>0.0.0.1, 0.0.0.2, 0.0.0.3</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下的 <code>maxTrustedIndex</code> 值产生以下的远程地址。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>maxTrustedIndex</code></th>
<th class="tableblock halign-left valign-top">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code>Integer.MIN_VALUE</code>,0]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(无效, 初始化时会抛出 <code>IllegalArgumentException</code> 异常)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[4, <code>Integer.MAX_VALUE</code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.1</p></td>
</tr>
</tbody>
</table>
<div id="gateway-route-filters" class="paragraph">
<p>下面的例子显示了如何用Java实现同样的配置。</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. GatewayConfig.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java">RemoteAddressResolver resolver = XForwardedRemoteAddressResolver
    .maxTrustedIndex(<span class="hljs-number">1</span>);

...

.route(<span class="hljs-string">"direct-route"</span>,
    r -&gt; r.remoteAddr(<span class="hljs-string">"10.1.1.1"</span>, <span class="hljs-string">"10.10.1.1/24"</span>)
        .uri(<span class="hljs-string">"https://downstream1"</span>)
.route(<span class="hljs-string">"proxied-route"</span>,
    r -&gt; r.remoteAddr(resolver, <span class="hljs-string">"10.10.1.1"</span>, <span class="hljs-string">"10.10.1.1/24"</span>)
        .uri(<span class="hljs-string">"https://downstream2"</span>)
)
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="weight"><a class="anchor" href="#weight"></a><a class="link" href="#weight">5.11. Weight</a></h3>
<div class="paragraph">
<p><code>Weight</code> 路由谓语工厂需要两个参数：<code>group</code> 和 <code>weight</code>（一个int值）。weight 是按 group 计算的。下面的例子配置了一个 weight 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_high</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://weighthigh.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group1,</span> <span class="hljs-number">8</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">weight_low</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://weightlow.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group1,</span> <span class="hljs-number">2</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此路由将转发~80%的流量到 <code><a href="https://weighthigh.org/" class="bare">weighthigh.org</a></code>，~20%的流量到 <code><a href="https://weighlow.org/" class="bare">weighlow.org</a></code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="xforwarded-remote-addr"><a class="anchor" href="#xforwarded-remote-addr"></a><a class="link" href="#xforwarded-remote-addr">5.12. XForwarded Remote Addr</a></h3>
<div class="paragraph">
<p><code>XForwarded Remote Addr</code> 路由谓语工厂接受一个 <code>sources</code> 集合（最长度为 1），这些 sources 是 CIDR注解（IPv4 或 IPv6）字符串，如 <code>192.168.0.1/16</code>（其中 <code>192.168.0.1</code> 是一个 IP 地址，<code>16</code> 是子网掩码）。</p>
</div>
<div class="paragraph">
<p>这个路由谓词允许根据 <code>X-Forwarded-For</code> 的 HTTP Header 对请求进行过滤。</p>
</div>
<div class="paragraph">
<p>这可以与反向代理一起使用，如负载均衡器或web应用防火墙，只有当请求来自这些反向代理所使用的受信任的IP地址列表时，才应该被允许。</p>
</div>
<div class="paragraph">
<p>下面的例子配置了一个 <code>XForwardedRemoteAddr</code> 路由谓词。</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">xforwarded_remoteaddr_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">XForwardedRemoteAddr=192.168.1.1/24</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，如果 <code>X-Forwarded-For</code> Header 包含 <code>192.168.1.10</code>，则该路由匹配。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="gatewayfilter-工厂"><a class="anchor" href="#gatewayfilter-%E5%B7%A5%E5%8E%82"></a><a class="link" href="#gatewayfilter-%E5%B7%A5%E5%8E%82">6. <code>GatewayFilter</code> 工厂</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>路由（Route）过滤器（Filter）允许以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应。路由过滤器的范围是一个特定的路由。Spring Cloud Gateway 包括许多内置的 <code>GatewayFilter</code> 工厂。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
关于如何使用以下任何过滤器的更详细的例子，请看 <a href="https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/filter/factory">单元测试</a>。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="addrequestheader"><a class="anchor" href="#addrequestheader"></a><a class="link" href="#addrequestheader">6.1. <code>AddRequestHeader</code></a></h3>
<div class="paragraph">
<p><code>AddRequestHeader</code> <code>GatewayFilter</code> 工厂需要一个 <code>name</code> 和 <code>value</code> 参数。下面的例子配置了一个 <code>AddRequestHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_request_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,</span> <span class="hljs-string">blue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个列表将 <code>X-Request-red:blue</code> header添加到所有匹配请求的下游请求的header信息中。</p>
</div>
<div class="paragraph">
<p><code>AddRequestHeader</code> 知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 <code>AddRequestHeader</code> <code>GatewayFilter</code>，它使用一个变量。</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_request_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/red/{segment}</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-Red,</span> <span class="hljs-string">Blue-{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="addrequestheadersifnotpresent"><a class="anchor" href="#addrequestheadersifnotpresent"></a><a class="link" href="#addrequestheadersifnotpresent">6.2. <code>AddRequestHeadersIfNotPresent</code></a></h3>
<div class="paragraph">
<p><code>AddRequestHeadersIfNotPresent</code> <code>GatewayFilter</code> 工厂接受一个由冒号分隔的 <code>name</code> 和 <code>value</code> 键值对的集合。下面的例子配置了一个 <code>AddRequestHeadersIfNotPresent</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_request_headers_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-2:green</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个列表为所有匹配的请求在下游请求的header信息中添加了两个header信息 <code>X-Request-Color-1:blue</code> 和 <code>X-Request-Color-2:green</code>。这类似于 <code>AddRequestHeader</code> 的工作方式，但与 <code>AddRequestHeader</code> 不同的是，它只在header 信息不存在的情况下才会这样做。否则，客户端请求中的原始值将被发送。</p>
</div>
<div class="paragraph">
<p>此外，要设置一个多值header，可以多次使用header的名称，如 <code>AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-1:green</code>。</p>
</div>
<div class="paragraph">
<p><code>AddRequestHeadersIfNotPresent</code> 也支持URI变量，用于匹配路径或主机。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个使用变量的 <code>AddRequestHeadersIfNotPresent</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_request_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/red/{segment}</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeadersIfNotPresent=X-Request-Red:Blue-{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="addrequestparameter"><a class="anchor" href="#addrequestparameter"></a><a class="link" href="#addrequestparameter">6.3. <code>AddRequestParameter</code></a></h3>
<div class="paragraph">
<p><code>AddRequestParameter</code> <code>GatewayFilter</code> Factory需要一个 <code>name</code> 和 <code>value</code> 参数。下面的例子配置了一个 <code>AddRequestParameter</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_request_parameter_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=red,</span> <span class="hljs-string">blue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将为所有匹配的请求在下游请求的查询字符串中添加 <code>red=blue</code>。</p>
</div>
<div class="paragraph">
<p><code>AddRequestParameter</code> 知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 <code>AddRequestParameter</code>  <code>GatewayFilter</code>，它使用了一个变量。</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_request_parameter_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">Host:</span> {<span class="hljs-string">segment</span>}<span class="hljs-string">.myhost.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=foo,</span> <span class="hljs-string">bar-{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="addresponseheader"><a class="anchor" href="#addresponseheader"></a><a class="link" href="#addresponseheader">6.4. <code>AddResponseHeader</code></a></h3>
<div class="paragraph">
<p><code>AddResponseHeader</code> <code>GatewayFilter</code> 工厂需要一个 <code>name</code> 和 <code>value</code> 参数。下面的例子配置了一个 <code>AddResponseHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_response_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response-Red,</span> <span class="hljs-string">Blue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将把 <code>X-Response-Red:Blue</code> header添加到所有匹配请求的下游响应的header中。</p>
</div>
<div class="paragraph">
<p><code>AddResponseHeader</code> 知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 <code>AddResponseHeader</code> <code>GatewayFilter</code>，它使用了一个变量。</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">add_response_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">Host:</span> {<span class="hljs-string">segment</span>}<span class="hljs-string">.myhost.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=foo,</span> <span class="hljs-string">bar-{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-circuitbreaker-filter-factory"><a class="anchor" href="#spring-cloud-circuitbreaker-filter-factory"></a><a class="link" href="#spring-cloud-circuitbreaker-filter-factory">6.5. <code>CircuitBreaker</code></a></h3>
<div class="paragraph">
<p>Spring Cloud CircuitBreaker GatewayFilter 工厂使用Spring Cloud CircuitBreaker API 将 Gateway 路由包裹在一个熔断器中。Spring Cloud CircuitBreaker 支持多个可与 Spring Cloud Gateway 一起使用的库。Spring Cloud 支持 Resilience4J 开箱即用。</p>
</div>
<div class="paragraph">
<p>要启用 Spring Cloud CircuitBreaker 过滤器，你需要添加 <code>spring-cloud-starter-circuitbreaker-reactor-resilience4j</code> 依赖。下面的例子配置了一个 Spring Cloud CircuitBreaker <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">circuitbreaker_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">CircuitBreaker=myCircuitBreaker</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要配置熔断器，请参阅你所使用的底层熔断器实现的配置。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html">Resilience4J 文档</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud CircuitBreaker 过滤器还可以接受一个可选的 <code>fallbackUri</code> 参数。目前，只支持 <code>forward:</code> 模式的URI。如果fallback被调用，请求将被转发到URI所匹配的控制器。下面的例子配置了这样一个fallback。</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">circuitbreaker_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://backing-service:8088</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/consumingServiceEndpoint</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CircuitBreaker</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">myCircuitBreaker</span>
            <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/inCaseOfFailureUseThis</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/consumingServiceEndpoint,</span> <span class="hljs-string">/backingServiceEndpoint</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以通过Java来实现相同的配置，如下。</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Application.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
        .route(<span class="hljs-string">"circuitbreaker_route"</span>, r -&gt; r.path(<span class="hljs-string">"/consumingServiceEndpoint"</span>)
            .filters(f -&gt; f.circuitBreaker(c -&gt; c.name(<span class="hljs-string">"myCircuitBreaker"</span>).fallbackUri(<span class="hljs-string">"forward:/inCaseOfFailureUseThis"</span>))
                .rewritePath(<span class="hljs-string">"/consumingServiceEndpoint"</span>, <span class="hljs-string">"/backingServiceEndpoint"</span>)).uri(<span class="hljs-string">"lb://backing-service:8088"</span>)
        .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当熔断器 fallback 被调用时，这个例子转发到 <code>/inCaseofFailureUseThis</code> URI。请注意，这个例子还演示了（可选）Spring Cloud LoadBalancer 的负载均衡（由目标URI上的 <code>lb</code> 前缀定义）。</p>
</div>
<div class="paragraph">
<p>CircuitBreaker 还支持 <code>fallbackUri</code> 中的URI变量。这允许更复杂的路由选项，比如使用 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.html">PathPattern 表达式</a> 转发原始主机或URL路径的部分。</p>
</div>
<div class="paragraph">
<p>在下面的例子中，调用 <code>consumingServiceEndpoint/users/1</code> 将被重定向到 <code>inCaseOfFailureUseThis/users/1</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">circuitbreaker_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://backing-service:8088</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/consumingServiceEndpoint/{*segments}</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CircuitBreaker</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">myCircuitBreaker</span>
            <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/inCaseOfFailureUseThis/{segments}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一般情况下是使用 <code>fallbackUri</code> 来定义网关应用程序中的内部controller或handler。然而，你也可以将请求重新路由到外部应用程序的controller或handler，如下所示。</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">ingredients</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://ingredients</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=//ingredients/**</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CircuitBreaker</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">fetchIngredients</span>
            <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/fallback</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">ingredients-fallback</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9994</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/fallback</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，网关应用程序中没有 <code>fallback</code> 端点或处理程序。然而，在另一个应用程序中有一个，在 <code><a href="http://localhost:9994/" class="bare">localhost:9994</a></code> 下注册。</p>
</div>
<div class="paragraph">
<p>在请求被转发到 fallback 的情况下，Spring Cloud CircuitBreaker Gateway 过滤器也提供了造成这种情况的 <code>Throwable</code>。它作为 <code>ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR</code> 属性被添加到 <code>ServerWebExchange</code> 中，在网关应用中处理 fallback 时可以使用。</p>
</div>
<div class="paragraph">
<p>对于外部 controller/handler 的情况，可以添加带有异常细节的header。你可以在<a href="#fallback-headers">FallbackHeaders GatewayFilter Factory 部分</a>找到更多关于这样做的信息。</p>
</div>
<div class="sect3">
<h4 id="circuit-breaker-status-codes"><a class="anchor" href="#circuit-breaker-status-codes"></a><a class="link" href="#circuit-breaker-status-codes">6.5.1. 熔断指定的状态码</a></h4>
<div class="paragraph">
<p>在某些情况下，你可能想根据它所包裹的路由返回的状态码来熔断。断路器配置对象需要一个状态码列表，如果返回这些代码将导致断路器熔断。当设置你想让断路器熔断的状态代码时，你可以使用一个带有状态码值的 int 或 <code>HttpStatus</code> 枚举的字符串表示。</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">circuitbreaker_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://backing-service:8088</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/consumingServiceEndpoint</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CircuitBreaker</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">myCircuitBreaker</span>
            <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/inCaseOfFailureUseThis</span>
            <span class="hljs-attr">statusCodes:</span>
              <span class="hljs-bullet">-</span> <span class="hljs-number">500</span>
              <span class="hljs-bullet">-</span> <span class="hljs-string">"NOT_FOUND"</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 28. Application.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
        .route(<span class="hljs-string">"circuitbreaker_route"</span>, r -&gt; r.path(<span class="hljs-string">"/consumingServiceEndpoint"</span>)
            .filters(f -&gt; f.circuitBreaker(c -&gt; c.name(<span class="hljs-string">"myCircuitBreaker"</span>).fallbackUri(<span class="hljs-string">"forward:/inCaseOfFailureUseThis"</span>).addStatusCode(<span class="hljs-string">"INTERNAL_SERVER_ERROR"</span>))
                .rewritePath(<span class="hljs-string">"/consumingServiceEndpoint"</span>, <span class="hljs-string">"/backingServiceEndpoint"</span>)).uri(<span class="hljs-string">"lb://backing-service:8088"</span>)
        .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cacherequestbody"><a class="anchor" href="#cacherequestbody"></a><a class="link" href="#cacherequestbody">6.6. <code>CacheRequestBody</code></a></h3>
<div class="paragraph">
<p>有些情况下，有必要读取请求体。由于请求体只能被读取一次，我们需要缓存请求体。你可以使用 <code>CacheRequestBody</code> 过滤器来缓存请求体，然后再把它发送到下游，从 <code>exchange</code> 属性中获取请求体。</p>
</div>
<div class="paragraph">
<p>下面显示了如何缓存请求体 <code>GatewayFilter</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
        .route(<span class="hljs-string">"cache_request_body_route"</span>, r -&gt; r.path(<span class="hljs-string">"/downstream/**"</span>)
            .filters(f -&gt; f.prefixPath(<span class="hljs-string">"/httpbin"</span>)
                .cacheRequestBody(String.class).uri(uri))
        .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 29. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cache_request_body_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://downstream</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/downstream/**</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CacheRequestBody</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">bodyClass:</span> <span class="hljs-string">java.lang.String</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>CacheRequestBody</code> 提取请求体并将其转换为一个 body 类（比如前面例子中定义的 <code>java.lang.String</code>）。然后，<code>CacheRequestBody</code> 把它放在 <code>ServerWebExchange.getAttributes()</code> 提供的属性中，其KEY值在 <code>ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR</code> 中定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个过滤器只对HTTP（包括HTTPS）请求起作用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="deduperesponseheader"><a class="anchor" href="#deduperesponseheader"></a><a class="link" href="#deduperesponseheader">6.7. <code>DedupeResponseHeader</code></a></h3>
<div class="paragraph">
<p><code>DedupeResponseHeader</code> <code>GatewayFilter</code> 工厂接受一个 <code>name</code> 参数和一个可选的 <code>strategy</code> 参数。<code>name</code> 可以包含一个以空格分隔的header名称列表。下面的例子配置了一个 <code>DedupeResponseHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">dedupe_response_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">DedupeResponseHeader=Access-Control-Allow-Credentials</span> <span class="hljs-string">Access-Control-Allow-Origin</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在网关CORS逻辑和下游逻辑都添加了 <code>Access-Control-Allow-Credentials</code> 和 <code>Access-Control-Allow-Origin</code> 响应头的情况下，这将删除重复的值。</p>
</div>
<div class="paragraph">
<p><code>DedupeResponseHeader</code> 过滤器还接受一个可选的 <code>strategy</code> 参数。接受的值是 <code>RETAIN_FIRST</code>（默认）、<code>RETAIN_LAST</code> 和 <code>RETAIN_UNIQUE</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="fallback-headers"><a class="anchor" href="#fallback-headers"></a><a class="link" href="#fallback-headers">6.8. <code>FallbackHeaders</code></a></h3>
<div class="paragraph">
<p>通过 <code>FallbackHeaders</code> 工厂，你可以在转发到外部应用程序中的 <code>fallbackUri</code> 的请求的header中添加Spring Cloud CircuitBreaker的执行异常细节，如以下场景。</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">ingredients</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://ingredients</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=//ingredients/**</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CircuitBreaker</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">fetchIngredients</span>
            <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/fallback</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">ingredients-fallback</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9994</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/fallback</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">FallbackHeaders</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">executionExceptionTypeHeaderName:</span> <span class="hljs-string">Test-Header</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，在运行断路器时发生执行异常后，请求被转发到运行在 <code>localhost:9994</code> 的应用程序中的 <code>fallback</code> 端点或 handler。带有异常类型、消息和（如果有）根本原因的异常类型和消息的 header 被 <code>FallbackHeaders</code> 过滤器添加到该请求中。</p>
</div>
<div class="paragraph">
<p>你可以通过设置以下参数的值（显示为默认值）来覆盖配置中header的名称。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>executionExceptionTypeHeaderName</code> (<code>"Execution-Exception-Type"</code>)</p>
</li>
<li>
<p><code>executionExceptionMessageHeaderName</code> (<code>"Execution-Exception-Message"</code>)</p>
</li>
<li>
<p><code>rootCauseExceptionTypeHeaderName</code> (<code>"Root-Cause-Exception-Type"</code>)</p>
</li>
<li>
<p><code>rootCauseExceptionMessageHeaderName</code> (<code>"Root-Cause-Exception-Message"</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>关于断路器和网关的更多信息，请参见 <a href="#spring-cloud-circuitbreaker-filter-factory">Spring Cloud CircuitBreaker Factory 部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="jsontogrpc"><a class="anchor" href="#jsontogrpc"></a><a class="link" href="#jsontogrpc">6.9. <code>JsonToGrpc</code></a></h3>
<div class="paragraph">
<p><code>JSONToGRPCFilter</code> <code>GatewayFilter</code> Factory 将一个JSON payload 转换为gRPC请求。</p>
</div>
<div class="paragraph">
<p>该过滤器需要以下参数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>protoDescriptor</code>: Proto描述文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个文件可以用 <code>protoc</code> 生成，并指定 <code>--descriptor_set_out</code> 标志。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash hljs" data-lang="bash">protoc --proto_path=src/main/resources/proto/ \
--descriptor_set_out=src/main/resources/proto/hello.pb  \
src/main/resources/proto/hello.proto</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>protoFile</code>: Proto定义文件。</p>
</li>
<li>
<p><code>service</code>: 处理请求的服务的全名称。</p>
</li>
<li>
<p><code>method</code>: 处理该请求的服务中的方法名称。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
支持 <code>streaming</code>。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>application.yml.</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
            .route(<span class="hljs-string">"json-grpc"</span>, r -&gt; r.path(<span class="hljs-string">"/json/hello"</span>).filters(f -&gt; {
                String protoDescriptor = <span class="hljs-string">"file:src/main/proto/hello.pb"</span>;
                String protoFile = <span class="hljs-string">"file:src/main/proto/hello.proto"</span>;
                String service = <span class="hljs-string">"HelloService"</span>;
                String method = <span class="hljs-string">"hello"</span>;
                <span class="hljs-keyword">return</span> f.jsonToGRPC(protoDescriptor, protoFile, service, method);
            }).uri(uri))
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">json-grpc</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">https://localhost:6565/testhello</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/json/**</span>
          <span class="hljs-attr">filters:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">JsonToGrpc</span>
              <span class="hljs-attr">args:</span>
                <span class="hljs-attr">protoDescriptor:</span> <span class="hljs-string">file:proto/hello.pb</span>
                <span class="hljs-attr">protoFile:</span> <span class="hljs-string">file:proto/hello.proto</span>
                <span class="hljs-attr">service:</span> <span class="hljs-string">com.example.grpcserver.hello.HelloService</span>
                <span class="hljs-attr">method:</span> <span class="hljs-string">hello</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>当通过网关向 <code>/json/hello</code> 发出请求时，该请求通过使用 <code>hello.proto</code> 中提供的定义进行转换，发送到 <code>com.example.grpcserver.hello.HelloService/hello</code>，返回的响应被转换为JSON。</p>
</div>
<div class="paragraph">
<p>默认情况下，它通过使用默认的 <code>TrustManagerFactory</code> 创建一个 <code>NettyChannel</code>。然而，你可以通过创建一个 <code>GrpcSslConfigurer</code> 类型的bean来定制这个 <code>TrustManager</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GRPCLocalConfiguration</span> </span>{
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> GRPCSSLContext <span class="hljs-title">sslContext</span><span class="hljs-params">()</span> </span>{
        TrustManager trustManager = trustAllCerts();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GRPCSSLContext(trustManager);
    }
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="localresponsecache"><a class="anchor" href="#localresponsecache"></a><a class="link" href="#localresponsecache">6.10. <code>LocalResponseCache</code></a></h3>
<div class="paragraph">
<p>这个过滤器允许缓存响应体和header，遵循以下规则。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它只能缓存无请求体的GET请求。</p>
</li>
<li>
<p>它只对以下状态代码之一的响应进行缓存。HTTP 200（OK），HTTP 206（部分内容），或HTTP 301（永久移动）。</p>
</li>
<li>
<p>如果 <code>Cache-Control</code> header不允许，响应数据就不会被缓存（请求中存在 <code>no-store</code> 或响应中存在 <code>no-store</code> 或 <code>private</code>）。</p>
</li>
<li>
<p>如果响应已经被缓存，并且在 <code>Cache-Control</code> 头中用 <code>no-cache</code> 值执行一个新的请求，它将返回一个304（未修改）的无body的响应。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个过滤器（配置每个路由的本地响应缓存）只有在启用了<a href="#local-cache-response-global-filter">本地响应全局缓存</a>的情况下才可用。</p>
</div>
<div class="paragraph">
<p>它接受第一个参数，用于覆盖缓存条目过期的时间（用 <code>s</code> 表示秒，用 <code>m</code> 表示分钟，用 <code>h</code> 表示小时），第二个参数用于设置该路由驱逐条目的最大缓存大小（KB、MB或GB）。</p>
</div>
<div class="paragraph">
<p>下面的列表显示了如何添加本地响应缓存 <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
        .route(<span class="hljs-string">"rewrite_response_upper"</span>, r -&gt; r.host(<span class="hljs-string">"*.rewriteresponseupper.org"</span>)
            .filters(f -&gt; f.prefixPath(<span class="hljs-string">"/httpbin"</span>)
                .localResponseCache(Duration.ofMinutes(<span class="hljs-number">30</span>), <span class="hljs-string">"500MB"</span>)
            ).uri(uri))
        .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>或者，这样：</p>
</div>
<div class="listingblock">
<div class="title">application.yaml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">resource</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/resource</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">LocalResponseCache=30m,500MB</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个过滤器还自动计算 HTTP <code>Cache-Control</code> header中的 <code>max-age</code> 值。只有在原始响应中存在 <code>max-age</code> 的情况下，才会用 <code>timeToLive</code> 配置参数中设置的秒数重写该值。在连续的调用中，这个值会以响应过期前的剩余秒数重新计算。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="maprequestheader"><a class="anchor" href="#maprequestheader"></a><a class="link" href="#maprequestheader">6.11. <code>MapRequestHeader</code></a></h3>
<div class="paragraph">
<p><code>MapRequestHeader</code> <code>GatewayFilter</code> 工厂接受 <code>fromHeader</code> 和 <code>toHeader</code> 参数。它创建一个新的命名header（<code>toHeader</code>），并从传入的http请求的现有命名头（<code>fromHeader</code>）中提取值。如果输入的header不存在，过滤器没有任何影响。如果新的命名header信息已经存在，它的值就会被增加新的值。下面的例子配置了一个 <code>MapRequestHeader</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">map_request_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">MapRequestHeader=Blue,</span> <span class="hljs-string">X-Request-Red</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将在下游请求中添加 <code>X-Request-Red:&lt;values&gt;</code> 头，并从传入的HTTP请求的 <code>Blue</code> 头中更新数值。</p>
</div>
</div>
<div class="sect2">
<h3 id="modifyrequestbody"><a class="anchor" href="#modifyrequestbody"></a><a class="link" href="#modifyrequestbody">6.12. <code>ModifyRequestBody</code></a></h3>
<div class="paragraph">
<p>你可以使用 <code>ModifyRequestBody</code> 过滤器，在网关向下游发送请求体之前对其进行修改。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个过滤器只能通过使用Java DSL来配置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面显示了如何使用 <code>GatewayFilter</code> 修改请求体：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
        .route(<span class="hljs-string">"rewrite_request_obj"</span>, r -&gt; r.host(<span class="hljs-string">"*.rewriterequestobj.org"</span>)
            .filters(f -&gt; f.prefixPath(<span class="hljs-string">"/httpbin"</span>)
                .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE,
                    (exchange, s) -&gt; <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-keyword">new</span> Hello(s.toUpperCase())))).uri(uri))
        .build();
}

<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>{
    String message;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span> </span>{ }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hello</span><span class="hljs-params">(String message)</span> </span>{
        <span class="hljs-keyword">this</span>.message = message;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> message;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessage</span><span class="hljs-params">(String message)</span> </span>{
        <span class="hljs-keyword">this</span>.message = message;
    }
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果请求没有正文，<code>RewriteFilter</code> 将被传递为 <code>null</code>。应该返回 <code>Mono.empty()</code> 来指定请求中缺少的主体。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modifyresponsebody"><a class="anchor" href="#modifyresponsebody"></a><a class="link" href="#modifyresponsebody">6.13. <code>ModifyResponseBody</code></a></h3>
<div class="paragraph">
<p>你可以使用 <code>ModifyResponseBody</code> 过滤器来修改响应体，然后再把它送回给客户端。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个过滤器只能通过使用Java DSL来配置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面显示了如何使用 <code>GatewayFilter</code> 修改响应体 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
        .route(<span class="hljs-string">"rewrite_response_upper"</span>, r -&gt; r.host(<span class="hljs-string">"*.rewriteresponseupper.org"</span>)
            .filters(f -&gt; f.prefixPath(<span class="hljs-string">"/httpbin"</span>)
                .modifyResponseBody(String.class, String.class,
                    (exchange, s) -&gt; Mono.just(s.toUpperCase()))).uri(uri))
        .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果响应没有正文，<code>RewriteFilter</code> 将被传递为 <code>null</code>。应该返回 <code>Mono.empty()</code> 来指定响应中缺少的主体。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="prefixpath"><a class="anchor" href="#prefixpath"></a><a class="link" href="#prefixpath">6.14. <code>PrefixPath</code></a></h3>
<div class="paragraph">
<p><code>PrefixPath</code> <code>GatewayFilter</code> 工厂需要一个 <code>prefix</code>  参数。下面的例子配置了一个 <code>PrefixPath</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">prefixpath_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">PrefixPath=/mypath</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这就把 <code>/mypath</code> 作为所有匹配请求的路径的前缀。因此，一个到 <code>/hello</code> 的请求会被发送到 <code>/mypath/hello</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="preservehostheader"><a class="anchor" href="#preservehostheader"></a><a class="link" href="#preservehostheader">6.15. <code>PreserveHostHeader</code></a></h3>
<div class="paragraph">
<p><code>PreserveHostHeader</code> <code>GatewayFilter</code> 工厂没有参数。这个过滤器设置一个请求属性（request attribute），路由过滤器（routing filter）会检查该属性，以确定是否应该发送原始的主机头，而不是由HTTP客户端确定的主机头。下面的例子配置了一个 <code>PreserveHostHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">preserve_host_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">PreserveHostHeader</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redirectto"><a class="anchor" href="#redirectto"></a><a class="link" href="#redirectto">6.16. <code>RedirectTo</code></a></h3>
<div class="paragraph">
<p><code>RedirectTo</code> <code>GatewayFilter</code> 工厂需要两个参数，<code>status</code> 和 <code>url</code>。<code>status</code> 参数应该是一个300系列的重定向 HTTP 状态码，如301。<code>url</code> 参数应该是一个有效的URL。这就是 <code>Location</code> header 的值。对于相对重定向，你应该使用 <code>uri: no://op</code> 作为路由定义的uri。下面的列表配置了一个 <code>RedirectTo</code>  <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">prefixpath_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RedirectTo=302,</span> <span class="hljs-string">https://acme.org</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将发送一个带有 <code>Location:https://acme.org</code> header的302状态码的响应，以执行重定向。</p>
</div>
</div>
<div class="sect2">
<h3 id="removejsonattributesresponsebody"><a class="anchor" href="#removejsonattributesresponsebody"></a><a class="link" href="#removejsonattributesresponsebody">6.17. <code>RemoveJsonAttributesResponseBody</code></a></h3>
<div class="paragraph">
<p><code>RemoveJsonAttributesResponseBody</code> <code>GatewayFilter</code> 工厂接收了一个要搜索的属性名称（<code>attribute name</code>）集合，列表中的最后一个参数可以是一个布尔值，用来删除根级的属性（如果该参数未定义，那就是默认值 <code>false</code>）或递归（<code>true</code>）。它提供了一个方便的方法，通过删除属性来应用于JSON body内容的转换。</p>
</div>
<div class="paragraph">
<p>下面的例子配置了一个 <code>RemoveJsonAttributesResponseBody</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">removejsonattributes_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoveJsonAttributesResponseBody=id,color</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这从根层的JSON body中删除了属性 "id" 和 "color"。</p>
</div>
<div class="paragraph">
<p>下面的例子配置了一个 <code>RemoveJsonAttributesResponseBody</code> <code>GatewayFilter</code>，它使用了可选的最后参数。</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">removejsonattributes_recursively_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/red/{segment}</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoveJsonAttributesResponseBody=id,color,true</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将从任何级别的JSON body中移除属性 "id" 和 "color"。</p>
</div>
</div>
<div class="sect2">
<h3 id="removerequestheader"><a class="anchor" href="#removerequestheader"></a><a class="link" href="#removerequestheader">6.18. <code>RemoveRequestHeader</code></a></h3>
<div class="paragraph">
<p><code>RemoveRequestHeader</code> <code>GatewayFilter</code> 工厂需要一个 <code>name</code> 参数。它是要被删除的header的名称。下面配置了一个 <code>RemoveRequestHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">removerequestheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoveRequestHeader=X-Request-Foo</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这在向下游发送之前删除了 <code>X-Request-Foo</code> 标头。</p>
</div>
</div>
<div class="sect2">
<h3 id="removerequestparameter"><a class="anchor" href="#removerequestparameter"></a><a class="link" href="#removerequestparameter">6.19. <code>RemoveRequestParameter</code></a></h3>
<div class="paragraph">
<p><code>RemoveRequestParameter</code> <code>GatewayFilter</code> 工厂需要一个 <code>name</code> 参数。它是要删除的查询参数的名称。下面的例子配置了一个 <code>RemoveRequestParameter</code>  <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">removerequestparameter_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoveRequestParameter=red</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将在向下游发送之前删除 <code>red</code> 参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="removeresponseheader"><a class="anchor" href="#removeresponseheader"></a><a class="link" href="#removeresponseheader">6.20. <code>RemoveResponseHeader</code></a></h3>
<div class="paragraph">
<p><code>RemoveResponseHeader</code> <code>GatewayFilter</code> 工厂需要一个 <code>name</code> 参数。它是要被移除的 header 的名称。下面的列表配置了一个 <code>RemoveResponseHeader</code>  <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">removeresponseheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RemoveResponseHeader=X-Response-Foo</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将在响应返回到网关客户端之前从响应中删除 <code>X-Response-Foo</code> 头。</p>
</div>
<div class="paragraph">
<p>要删除任何类型的敏感标头，你应该为任何你可能想这样做的路由配置这个过滤器。此外，你可以通过使用 <code>spring.cloud.gateway.default-filters</code> 配置一次此过滤器，并将其应用于所有路由。</p>
</div>
</div>
<div class="sect2">
<h3 id="requestheadersize"><a class="anchor" href="#requestheadersize"></a><a class="link" href="#requestheadersize">6.21. <code>RequestHeaderSize</code></a></h3>
<div class="paragraph">
<p><code>RequestHeaderSize</code> <code>GatewayFilter</code> 工厂接受 <code>maxSize</code> 和 <code>errorHeaderName</code> 参数。<code>maxSize</code> 参数是请求头（包括key和value）所允许的最大数据大小。<code>errorHeaderName</code> 参数设置包含错误信息的响应头的名称，默认为 "errorMessage"。下面的列表配置了一个 <code>RequestHeaderSize</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">requestheadersize_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RequestHeaderSize=1000B</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果任何请求头的大小超过1000字节，这将发送一个 431状态码的响应。</p>
</div>
</div>
<div class="sect2">
<h3 id="requestratelimiter"><a class="anchor" href="#requestratelimiter"></a><a class="link" href="#requestratelimiter">6.22. <code>RequestRateLimiter</code></a></h3>
<div class="paragraph">
<p><code>RequestRateLimiter</code> <code>GatewayFilter</code> 工厂使用 <code>RateLimiter</code> 实现来确定是否允许当前请求继续进行。如果不允许，就会返回 <code>HTTP 429 - Too Many Requests</code>（默认）的状态。</p>
</div>
<div class="paragraph">
<p>这个过滤器需要一个可选的 <code>keyResolver</code> 参数和特定于速率限制器的参数（在<a href="#key-resolver-section">本节后面</a>描述）。</p>
</div>
<div class="paragraph">
<p><code>keyResolver</code> 是一个实现了 <code>KeyResolver</code> 接口的Bean。在配置中，使用SpEL来引用Bean的名字。<code>#{@myKeyResolver}</code> 是一个SpEL表达式，它引用了一个名为 <code>myKeyResolver</code> 的bean。下面的列表显示了 <code>KeyResolver</code> 的接口。</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. KeyResolver.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KeyResolver</span> </span>{
    <span class="hljs-function">Mono&lt;String&gt; <span class="hljs-title">resolve</span><span class="hljs-params">(ServerWebExchange exchange)</span></span>;
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div id="key-resolver-section" class="paragraph">
<p><code>KeyResolver</code> 接口让可插拔的策略导出限制请求的key。在未来的里程碑版本中，会有一些 <code>KeyResolver</code> 的实现。</p>
</div>
<div class="paragraph">
<p><code>KeyResolver</code> 的默认实现是 <code>PrincipalNameKeyResolver</code>，它从 <code>ServerWebExchange</code> 中检索 <code>Principal</code> 并调用 <code>Principal.getName()</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果 <code>KeyResolver</code> 没有找到一个 <code>key</code>，请求会被拒绝。你可以通过设置 <code>spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key</code>（<code>true</code> 或 <code>false</code>）和 <code>spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code</code> 属性来调整这种行为。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>RequestRateLimiter</code> 不能用 "快捷方式" 来配置。下面的例子是无效的。</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. application.properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre># 无效的快捷方式配置
spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=2, 2, #{@userkeyresolver}</pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="redis-ratelimiter"><a class="anchor" href="#redis-ratelimiter"></a><a class="link" href="#redis-ratelimiter">6.22.1. Redis <code>RateLimiter</code></a></h4>
<div class="paragraph">
<p>Redis的实现是基于 <a href="https://stripe.com/blog/rate-limiters">Stripe</a> 的工作。它需要使用 <code>spring-boot-starter-data-redis-reactive</code> Spring Boot Starter。</p>
</div>
<div class="paragraph">
<p>使用的算法是 <a href="https://en.wikipedia.org/wiki/Token_bucket">令牌桶算法</a>。</p>
</div>
<div class="paragraph">
<p><code>redis-rate-limiter.replenishRate</code> 属性定义了每秒钟允许多少个请求（不算放弃的请求）。这是令牌桶被填充的速度。</p>
</div>
<div class="paragraph">
<p><code>redis-rate-limiter.burstCapacity</code> 属性是一个用户在一秒钟内允许的最大请求数（不算放弃的请求）。这是令牌桶可以容纳的令牌数量。将此值设置为零会阻止所有请求。</p>
</div>
<div class="paragraph">
<p><code>redis-rate-limiter.requestedTokens</code> 属性是指一个请求要花费多少令牌。这是为每个请求从桶中提取的令牌数量，默认为 <code>1</code>。</p>
</div>
<div class="paragraph">
<p>一个稳定的速率是通过在 <code>replenishRate</code> 和 <code>burstCapacity</code> 中设置相同的值来实现的。可以通过设置高于补给率的 <code>burstCapacity</code> 来允许临时的突发。在这种情况下，速率限制器需要在突发之间允许一些时间（根据 <code>replenishRate</code>），因为连续两次突发会导致请求被放弃（<code>HTTP 429 - Too Many Requests</code>）。下面的列表配置了一个 <code>redis-rate-limiter</code>。</p>
</div>
<div class="paragraph">
<p>低于 1个请求/s 的速率限制是通过将 <code>replenishRate</code> 设置为想要的请求数， <code>requestTokens</code> 设置为秒数，<code>burstCapacity</code> 设置为 <code>replenishRate</code> 和 <code>requestTokens</code> 的乘积来完成的。例如，设置 <code>replenishRate=1</code>，<code>requestedTokens=60</code>，<code>burstCapacity=60</code>，结果是1个请求/分钟的限制。</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">requestratelimiter_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">10</span>
            <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">20</span>
            <span class="hljs-attr">redis-rate-limiter.requestedTokens:</span> <span class="hljs-number">1</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子在Java中配置了一个 <code>KeyResolver</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. Config.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">KeyResolver <span class="hljs-title">userKeyResolver</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">"user"</span>));
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这定义了每个用户的请求率限制为10。爆发20次是允许的，但是，在下一秒，只有10个请求可用。<code>KeyResolver</code> 是一个简单的，获得 <code>user</code> 请求参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
不建议在生产中使用这个方法
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>你也可以把速率限制器定义为一个实现 <code>RateLimiter</code> 接口的bean。在配置中，你可以用SpEL来引用bean的名字。<code>#{@myRateLimiter}</code> 是一个SpEL表达式，它引用了一个名为 <code>myRateLimiter</code> 的 bean。下面的清单定义了一个速率限制器，它使用了前面清单中定义的 <code>KeyResolver</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">requestratelimiter_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">rate-limiter:</span> <span class="hljs-string">"#{@myRateLimiter}"</span>
            <span class="hljs-attr">key-resolver:</span> <span class="hljs-string">"#{@userKeyResolver}"</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rewritelocationresponseheader"><a class="anchor" href="#rewritelocationresponseheader"></a><a class="link" href="#rewritelocationresponseheader">6.23. <code>RewriteLocationResponseHeader</code></a></h3>
<div class="paragraph">
<p><code>RewriteLocationResponseHeader</code> <code>GatewayFilter</code> 工厂修改 <code>Location</code> 响应头的值，通常是为了去掉后台的特定细节。它需要 <code>stripVersionMode</code>、<code>locationHeaderName</code>、<code>hostValue</code> 和 <code>protocolsRegex</code> 参数。下面的清单配置了一个 <code>RewriteLocationResponseHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">rewritelocationresponseheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RewriteLocationResponseHeader=AS_IN_REQUEST,</span> <span class="hljs-string">Location,</span> <span class="hljs-string">,</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，对于一个 <code>POST <a href="https://api.example.com/some/object/name" class="bare">api.example.com/some/object/name</a></code> 的请求， <code>Location</code> 响应头值 <code><a href="https://object-service.prod.example.net/v2/some/object/id" class="bare">object-service.prod.example.net/v2/some/object/id</a></code> 被改写为 <code><a href="https://api.example.com/some/object/id" class="bare">api.example.com/some/object/id</a></code>。</p>
</div>
<div class="paragraph">
<p><code>stripVersionMode</code> 参数有以下可能的值。<code>NEVER_STRIP</code>、<code>AS_IN_REQUEST</code>（默认）和 <code>ALWAYS_STRIP</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEVER_STRIP</code>: 即使最初的请求路径不包含version，version也不会被剥离。</p>
</li>
<li>
<p><code>AS_IN_REQUEST</code>: 只有当原始请求路径不包含version时，才会剥离version。</p>
</li>
<li>
<p><code>ALWAYS_STRIP</code>: version 总是被剥离，即使原始请求路径包含version 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>hostValue</code> 参数，如果提供的话，将用于替换响应的 <code>Location</code> 头的 <code>host:port</code> 部分。如果没有提供，则使用 <code>Host</code> 请求头的值。</p>
</div>
<div class="paragraph">
<p><code>protocolsRegex</code> 参数必须是一个有效的 regex <code>String</code>，协议名称将与之匹配。如果没有匹配，过滤器不做任何事情。默认是 <code>http|https|ftp|ftps</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="rewritepath"><a class="anchor" href="#rewritepath"></a><a class="link" href="#rewritepath">6.24. <code>RewritePath</code></a></h3>
<div class="paragraph">
<p><code>RewritePath</code> <code>GatewayFilter</code> 工厂接收一个路径 <code>regexp</code> 参数和一个 <code>replacement</code> 参数。这是用Java正则表达式来重写请求路径的一种灵活方式。下面的列表配置了一个 <code>RewritePath</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">rewritepath_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/red/**</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/red/?(?&lt;segment&gt;.*),</span> <span class="hljs-string">/$\{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于请求路径为 <code>/red/blue</code> 的情况，在进行下游请求之前将路径设置为 <code>/blue</code>。注意，由于YAML的规范，<code>$</code> 应该被替换成 <code>$\</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="rewriteresponseheader"><a class="anchor" href="#rewriteresponseheader"></a><a class="link" href="#rewriteresponseheader">6.25. <code>RewriteResponseHeader</code></a></h3>
<div class="paragraph">
<p><code>RewriteResponseHeader</code> <code>GatewayFilter</code> 工厂接受 <code>name</code>、<code>regexp</code> 和 <code>replacement</code> 参数。它使用Java正则表达式，以一种灵活的方式重写响应头的值。下面的例子配置了一个 <code>RewriteResponseHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">rewriteresponseheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">RewriteResponseHeader=X-Response-Red,</span> <span class="hljs-string">,</span> <span class="hljs-string">password=[^&amp;]+,</span> <span class="hljs-string">password=***</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于一个 <code>/42?user=ford&amp;password=omg!what&amp;flag=true</code> 的header值，在发出下游请求后，它被设置为 <code>/42?user=ford&amp;password=***&amp;flag=true</code>。因为YAML规范，你必须用 <code>$\</code> 来表示 <code>$</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="savesession"><a class="anchor" href="#savesession"></a><a class="link" href="#savesession">6.26. <code>SaveSession</code></a></h3>
<div class="paragraph">
<p><code>SaveSession</code> <code>GatewayFilter</code> 工厂在转发下游调用之前强制进行 <code>WebSession::save</code> 操作。这在使用类似 <a href="https://projects.spring.io/spring-session/">Spring Session</a> 的懒数据存储时特别有用，因为你需要确保在进行转发调用之前已经保存了Session状态。下面的例子配置了一个 <code>SaveSession</code>  <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">save_session</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/foo/**</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SaveSession</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你将 <a href="https://projects.spring.io/spring-security/">Spring Security</a> 与 Spring Session 集成，并希望确保安全细节（security detail）已被转发到远程进程，这一点至关重要。</p>
</div>
</div>
<div class="sect2">
<h3 id="secureheaders"><a class="anchor" href="#secureheaders"></a><a class="link" href="#secureheaders">6.27. <code>SecureHeaders</code></a></h3>
<div class="paragraph">
<p>根据 <a href="https://blog.appcanary.com/2017/http-security-headers.html">这篇博客</a>的建议，<code>SecureHeaders</code> <code>GatewayFilter</code> 工厂在响应中添加了一些头信息。</p>
</div>
<div class="paragraph">
<p>以下header信息（显示为其默认值）被添加。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X-Xss-Protection:1 (mode=block</code>)</p>
</li>
<li>
<p><code>Strict-Transport-Security (max-age=631138519</code>)</p>
</li>
<li>
<p><code>X-Frame-Options (DENY)</code></p>
</li>
<li>
<p><code>X-Content-Type-Options (nosniff)</code></p>
</li>
<li>
<p><code>Referrer-Policy (no-referrer)</code></p>
</li>
<li>
<p><code>Content-Security-Policy (default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline)'</code></p>
</li>
<li>
<p><code>X-Download-Options (noopen)</code></p>
</li>
<li>
<p><code>X-Permitted-Cross-Domain-Policies (none)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要改变默认值，请在 <code>spring.cloud.gateway.filter.secure-headers</code> 命名空间中设置相应的属性。以下是可用的属性。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>xss-protection-header</code></p>
</li>
<li>
<p><code>strict-transport-security</code></p>
</li>
<li>
<p><code>frame-options</code></p>
</li>
<li>
<p><code>content-type-options</code></p>
</li>
<li>
<p><code>referrer-policy</code></p>
</li>
<li>
<p><code>content-security-policy</code></p>
</li>
<li>
<p><code>download-options</code></p>
</li>
<li>
<p><code>permitted-cross-domain-policies</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要禁用默认值，请用逗号分隔的值设置 <code>spring.cloud.gateway.filter.secure-headers.disable</code> 属性，如下。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="hljs gradle">spring.cloud.gateway.filter.secure-headers.disable=x-frame-<span class="hljs-keyword">options</span>,strict-transport-security</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
需要使用 secure header 的小写全名来禁用它。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="setpath"><a class="anchor" href="#setpath"></a><a class="link" href="#setpath">6.28. <code>SetPath</code></a></h3>
<div class="paragraph">
<p><code>SetPath</code> <code>GatewayFilter</code> 工厂接受一个路径模板参数。它提供了一种简单的方法，通过允许模板化的路径段来操作请求路径。这使用了 Spring Framework 的URI模板。允许多个匹配段。下面的例子配置了一个 <code>SetPath</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setpath_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/red/{segment}</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetPath=/{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于请求路径为 <code>/red/blue</code> 的情况，在进行下行请求之前，将路径设置为 <code>/blue</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="setrequestheader"><a class="anchor" href="#setrequestheader"></a><a class="link" href="#setrequestheader">6.29. <code>SetRequestHeader</code></a></h3>
<div class="paragraph">
<p><code>SetRequestHeader</code> <code>GatewayFilter</code> 工厂接受 <code>name</code> 和 <code>value</code> 参数。下面的列表配置了一个 <code>SetRequestHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setrequestheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetRequestHeader=X-Request-Red,</span> <span class="hljs-string">Blue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这 <code>GatewayFilter</code> 会替换（而不是添加）所有给定名称的 header 信息。
因此，如果下游服务器以 <code>X-Request-Red:1234</code> 响应，它将被替换为 <code>X-Request-Red:Blue</code>，这就是下游服务会收到的。</p>
</div>
<div class="paragraph">
<p><code>SetRequestHeader</code> 知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 <code>SetRequestHeader</code> <code>GatewayFilter</code>，它使用了一个变量。</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setrequestheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">Host:</span> {<span class="hljs-string">segment</span>}<span class="hljs-string">.myhost.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetRequestHeader=foo,</span> <span class="hljs-string">bar-{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setresponseheader"><a class="anchor" href="#setresponseheader"></a><a class="link" href="#setresponseheader">6.30. <code>SetResponseHeader</code></a></h3>
<div class="paragraph">
<p><code>SetResponseHeader</code> <code>GatewayFilter</code> 工厂接受 <code>name</code> 和 <code>value</code> 参数。下面的列表配置了一个 <code>SetResponseHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setresponseheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetResponseHeader=X-Response-Red,</span> <span class="hljs-string">Blue</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个 <code>GatewayFilter</code> 会替换（而不是添加）所有带有给定名称的头信息。
因此，如果下游服务器以 <code>X-Response-Red:1234</code> 响应，它将被替换为 <code>X-Response-Red:Blue</code>，这就是网关客户端将收到的内容。</p>
</div>
<div class="paragraph">
<p><code>SetResponseHeader</code> 知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并将在运行时被扩展。下面的例子配置了一个 <code>SetResponseHeader</code> <code>GatewayFilter</code>，它使用了一个变量。</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setresponseheader_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">Host:</span> {<span class="hljs-string">segment</span>}<span class="hljs-string">.myhost.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetResponseHeader=foo,</span> <span class="hljs-string">bar-{segment}</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setstatus"><a class="anchor" href="#setstatus"></a><a class="link" href="#setstatus">6.31. <code>SetStatus</code></a></h3>
<div class="paragraph">
<p><code>SetStatus</code> <code>GatewayFilter</code> 工厂只接受一个参数，即 <code>status</code>。它必须是一个有效的Spring <code>HttpStatus</code>。它可以是 <code>404</code> 的int值或枚举的字符串表示: <code>NOT_FOUND</code>。下面的列表配置了一个 <code>SetStatus</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setstatusstring_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=UNAUTHORIZED</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setstatusint_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=401</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，响应的HTTP状态被设置为401。</p>
</div>
<div class="paragraph">
<p>你可以配置 <code>SetStatus</code> <code>GatewayFilter</code>，使其在响应中的头中返回代理请求的原始HTTP状态代码。如果配置了以下属性，该头会被添加到响应中。</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">set-status:</span>
        <span class="hljs-attr">original-status-header-name:</span> <span class="hljs-string">original-http-status</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stripprefix"><a class="anchor" href="#stripprefix"></a><a class="link" href="#stripprefix">6.32. <code>StripPrefix</code></a></h3>
<div class="paragraph">
<p><code>StripPrefix</code> <code>GatewayFilter</code> 工厂需要一个参数，即 <code>parts</code>。<code>parts</code> 参数表示在向下游发送请求之前要从路径中剥离的部分的数量。下面的列表配置了一个 <code>StripPrefix</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">nameRoot</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://nameservice</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/name/**</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=2</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当通过网关向 <code>/name/blue/red</code> 发出请求时，向 <code>nameservice</code> 发出的请求看起来像 <code><a href="https://nameservice/red" class="bare">nameservice/red</a></code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="retry"><a class="anchor" href="#retry"></a><a class="link" href="#retry">6.33. <code>Retry</code></a></h3>
<div class="paragraph">
<p><code>Retry</code> <code>GatewayFilter</code> 工厂支持以下参数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>retries</code>: 应该尝试的重试次数。</p>
</li>
<li>
<p><code>statuses</code>: 应该重试的HTTP状态代码，用 <code>org.springframework.http.HttpStatus</code> 表示。</p>
</li>
<li>
<p><code>methods</code>: 应该重试的HTTP方法，用 <code>org.springframework.http.HttpMethod</code> 来表示。</p>
</li>
<li>
<p><code>series</code>: 要重试的状态代码系列，用 <code>org.springframework.http.HttpStatus.Series</code> 表示。</p>
</li>
<li>
<p><code>exceptions</code>: 抛出的异常的列表，应该重试。</p>
</li>
<li>
<p><code>backoff</code>: 为重试配置的指数式backoff。重试是在 <code>backoff</code> 间隔 <code>firstBackoff * (factor ^ n)</code> 之后进行的，其中 <code>n</code> 是迭代次数。如果配置了 <code>maxBackoff</code>，应用的最大 backoff 时间被限制在 <code>maxBackoff</code>。如果 <code>basedOnPreviousValue</code> 为 <code>true</code>，则通过使用 <code>prevBackoff * factor</code> 来计算backoff。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果启用，为 <code>Retry</code> filter 配置的默认值如下。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>retries</code>: 三次</p>
</li>
<li>
<p><code>series</code>: 5XX系列</p>
</li>
<li>
<p><code>methods</code>: GET 请求</p>
</li>
<li>
<p><code>exceptions</code>: <code>IOException</code> 和 <code>TimeoutException</code></p>
</li>
<li>
<p><code>backoff</code>: disabled</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面配置了一个 <code>Retry</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 59. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">retry_test</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8080/flakey</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Host=*.retry.com</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Retry</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
            <span class="hljs-attr">statuses:</span> <span class="hljs-string">BAD_GATEWAY</span>
            <span class="hljs-attr">methods:</span> <span class="hljs-string">GET,POST</span>
            <span class="hljs-attr">backoff:</span>
              <span class="hljs-attr">firstBackoff:</span> <span class="hljs-string">10ms</span>
              <span class="hljs-attr">maxBackoff:</span> <span class="hljs-string">50ms</span>
              <span class="hljs-attr">factor:</span> <span class="hljs-number">2</span>
              <span class="hljs-attr">basedOnPreviousValue:</span> <span class="hljs-literal">false</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当使用带有 <code>forward:</code> 前缀的URL的 retry filter 时，应仔细编写目标端点，以便在出现错误时，它不会做任何可能导致响应被发送到客户端并提交的事情。例如，如果目标端点是一个 <code>@Controller</code>，目标controller方法不应该返回带有错误状态码的 <code>ResponseEntity</code>。相反，它应该抛出一个 <code>Exception</code> 或发出一个错误信号（例如，通过 <code>Mono.error(ex)</code> 返回值），retry filter 可以被配置为通过重试来处理。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
当对任何带有body的HTTP方法使用 retry filter 时，body将被缓存，网关将变得内存受限。body被缓存在 <code>ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR</code> 定义的请求属性（request attribute）中。该对象的类型是 <code>org.springframework.core.io.buffer.DataBuffer</code>。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一个简化的 "快捷" 方式可以用一个 <code>status</code> 和 <code>method</code> 来添加。</p>
</div>
<div class="paragraph">
<p>以下两个例子是等同的。</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">retry_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Retry</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
            <span class="hljs-attr">statuses:</span> <span class="hljs-string">INTERNAL_SERVER_ERROR</span>
            <span class="hljs-attr">methods:</span> <span class="hljs-string">GET</span>
            <span class="hljs-attr">backoff:</span>
              <span class="hljs-attr">firstBackoff:</span> <span class="hljs-string">10ms</span>
              <span class="hljs-attr">maxBackoff:</span> <span class="hljs-string">50ms</span>
              <span class="hljs-attr">factor:</span> <span class="hljs-number">2</span>
              <span class="hljs-attr">basedOnPreviousValue:</span> <span class="hljs-literal">false</span>

      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">retryshortcut_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Retry=3,INTERNAL_SERVER_ERROR,GET,10ms,50ms,2,false</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="requestsize"><a class="anchor" href="#requestsize"></a><a class="link" href="#requestsize">6.34. <code>RequestSize</code></a></h3>
<div class="paragraph">
<p>当请求的大小超过允许的限制时，<code>RequestSize</code> <code>GatewayFilter</code> 工厂可以限制请求到达下游服务。该过滤器需要一个 <code>maxSize</code> 参数。<code>maxSize</code> 是一个 <code>DataSize</code> 类型，所以值可以定义为一个数字，后面有一个可选的 <code>DataUnit</code> 后缀，如 'KB' 或’MB'。默认是 'B'，表示字节。它是以字节为单位定义的请求的可允许的大小限制。下面的列表配置了一个 <code>RequestSize</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">request_size_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8080/upload</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/upload</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestSize</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">maxSize:</span> <span class="hljs-number">5000000</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>RequestSize</code> <code>GatewayFilter</code> 工厂将响应状态设置为 <code>413 Payload Too Large</code>，当请求由于大小而被拒绝时，会有一个额外的头 <code>errorMessage</code>。下面的例子显示了这样一个 <code>errorMessage</code>。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="hljs kotlin">errorMessage : Request size <span class="hljs-keyword">is</span> larger than permissible limit. Request size <span class="hljs-keyword">is</span> <span class="hljs-number">6.0</span> MB <span class="hljs-keyword">where</span> permissible limit <span class="hljs-keyword">is</span> <span class="hljs-number">5.0</span> MB</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果在路由定义中没有提供filter参数，默认请求大小被设置为5MB。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="setrequesthostheader"><a class="anchor" href="#setrequesthostheader"></a><a class="link" href="#setrequesthostheader">6.35. <code>SetRequestHostHeader</code></a></h3>
<div class="paragraph">
<p>在某些情况下，host 头可能需要被重写。在这种情况下，<code>SetRequestHostHeader</code>  <code>GatewayFilter</code> 工厂可以将现有的 <code>host</code> header 替换成指定的值。该过滤器需要一个 <code>host</code> 参数。下面的列表配置了一个 <code>SetRequestHostHeader</code> <code>GatewayFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">set_request_host_header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8080/headers</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/headers</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SetRequestHostHeader</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">host:</span> <span class="hljs-string">example.org</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>SetRequestHostHeader</code> <code>GatewayFilter</code> 工厂将 <code>host</code> 头的值替换为 <code>example.org</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="tokenrelay"><a class="anchor" href="#tokenrelay"></a><a class="link" href="#tokenrelay">6.36. <code>TokenRelay</code></a></h3>
<div class="paragraph">
<p>Token Relay是指OAuth2消费者作为客户端，将传入的令牌转发给传出的资源请求。消费者可以是一个纯粹的客户端（如SSO应用程序）或一个资源服务器。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway 可以将 OAuth2 访问令牌转发到它所代理的服务的下游。为了在网关中添加这一功能，你需要像这样添加 <code>TokenRelayGatewayFilterFactory</code>。</p>
</div>
<div class="listingblock">
<div class="title">App.java</div>
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">customRouteLocator</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
            .route(<span class="hljs-string">"resource"</span>, r -&gt; r.path(<span class="hljs-string">"/resource"</span>)
                    .filters(f -&gt; f.tokenRelay())
                    .uri(<span class="hljs-string">"http://localhost:9000"</span>))
            .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>或者，这样。</p>
</div>
<div class="listingblock">
<div class="title">application.yaml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">resource</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:9000</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/resource</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">TokenRelay=</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>它将（除了登录用户和抓取令牌之外）把认证令牌传递给下游的服务（在这里是 <code>/resource</code>）。</p>
</div>
<div class="paragraph">
<p>要为 Spring Cloud Gateway 启用这个功能，需要添加以下依赖</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.boot:spring-boot-starter-oauth2-client</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它是如何工作的？ {githubmaster}/src/main/java/org/springframework/cloud/gateway/security/TokenRelayGatewayFilterFactory.java[filter]从当前认证的用户中提取一个访问令牌，并将其放在下游请求的请求头中。</p>
</div>
<div class="paragraph">
<p>完整的工作样本见 <a href="https://github.com/spring-cloud-samples/sample-gateway-oauth2login">该项目</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
只有当适当的 <code>spring.security.oauth2.client.*</code> 属性被设置时， <code>TokenRelayGatewayFilterFactory</code> Bean才会被创建，这将触发 <code>ReactiveClientRegistrationRepository</code> Bean的创建。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TokenRelayGatewayFilterFactory</code> 使用的 <code>ReactiveOAuth2AuthorizedClientService</code> 的默认实现使用了一个内存数据存储。如果你需要一个更强大的解决方案，你将需要提供你自己的实现 <code>ReactiveOAuth2AuthorizedClientService</code>。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="默认-filter"><a class="anchor" href="#%E9%BB%98%E8%AE%A4-filter"></a><a class="link" href="#%E9%BB%98%E8%AE%A4-filter">6.37. 默认 Filter</a></h3>
<div class="paragraph">
<p>要添加一个filter并将其应用于所有路由，可以使用 <code>spring.cloud.gateway.default-filters</code>。这个属性需要一个filter的列表。下面的列表定义了一组默认filter。</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">default-filters:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=X-Response-Default-Red,</span> <span class="hljs-string">Default-Blue</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PrefixPath=/httpbin</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="全局-filter"><a class="anchor" href="#%E5%85%A8%E5%B1%80-filter"></a><a class="link" href="#%E5%85%A8%E5%B1%80-filter">7. 全局 Filter</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>GlobalFilter</code> 接口的签名与 <code>GatewayFilter</code> 相同。这些是特殊的过滤器，有条件地应用于所有路由。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个接口和它的用法在未来的里程碑版本中可能会有变化。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="gateway-combined-global-filter-and-gatewayfilter-ordering"><a class="anchor" href="#gateway-combined-global-filter-and-gatewayfilter-ordering"></a><a class="link" href="#gateway-combined-global-filter-and-gatewayfilter-ordering">7.1. <code>GlobalFilter</code> 组合和 <code>GatewayFilter</code> 的顺序</a></h3>
<div class="paragraph">
<p>当一个请求与路由匹配时，filter web handler将 <code>GlobalFilter</code> 的所有实例和 <code>GatewayFilter</code> 的所有路由特定实例添加到一个过滤链中。这个组合的过滤链由 <code>org.springframework.core.Ordered</code> 接口进行排序，你可以通过实现 <code>getOrder()</code> 方法来设置这个接口。</p>
</div>
<div class="paragraph">
<p>由于 Spring Cloud Gateway 区分了过滤器逻辑执行的 “pre” 和 “post” 阶段（见<a href="#gateway-how-it-works">如何工作</a>），优先级最高的过滤器在 “pre” 阶段是第一个，在 “post” 阶段是最后一个。</p>
</div>
<div class="paragraph">
<p>下面的列表配置了一个过滤器链。</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. ExampleConfiguration.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> GlobalFilter <span class="hljs-title">customFilter</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomGlobalFilter();
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{
        log.info(<span class="hljs-string">"custom global filter"</span>);
        <span class="hljs-keyword">return</span> chain.filter(exchange);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gateway-metrics指标-filter"><a class="anchor" href="#gateway-metrics%E6%8C%87%E6%A0%87-filter"></a><a class="link" href="#gateway-metrics%E6%8C%87%E6%A0%87-filter">7.2. Gateway Metrics（指标） Filter</a></h3>
<div class="paragraph">
<p>要启用网关指标，请添加 <code>spring-boot-starter-actuator</code> 作为项目依赖。然后，默认情况下，只要 <code>spring.cloud.gateway.metrics.enabled</code> 属性没有被设置为  <code>false</code>，网关指标过滤器就会运行。这个过滤器添加了一个名为 <code>spring.cloud.gateway.requests</code> 的定时器指标，标签如下。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>routeId</code>: 路由（route） ID.</p>
</li>
<li>
<p><code>routeUri</code>: API被路由到的URI。</p>
</li>
<li>
<p><code>outcome</code>: 结果，由 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html">HttpStatus.Series</a> 分类。</p>
</li>
<li>
<p><code>status</code>: 返回给客户端的请求的HTTP状态。</p>
</li>
<li>
<p><code>httpStatusCode</code>: 返回给客户端的请求的HTTP状态。</p>
</li>
<li>
<p><code>httpMethod</code>: 请求使用的HTTP方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，通过 <code>spring.cloud.gateway.metrics.tags.path.enabled</code> 属性（默认为 <code>false</code>），你可以用路径标签（path tag）激活一个额外的指标。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path</code>: 请求的路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些指标可以从 <code>/actuator/metrics/spring.cloud.gateway.requests</code> 中抓取，并可以很容易地与 <code>Prometheus</code> 集成，创建一个 <a href="images/gateway-grafana-dashboard.jpeg">Grafana</a> <a href="gateway-grafana-dashboard.json">dashboard</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要启用 Prometheus 端点，请将 <code>micrometer-registry-prometheus</code> 添加到项目依赖。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="local-cache-response-global-filter"><a class="anchor" href="#local-cache-response-global-filter"></a><a class="link" href="#local-cache-response-global-filter">7.3. Local Response Cache Filter</a></h3>
<div class="paragraph">
<p>如果 <code>LocalResponseCache</code> 的相关属性被启用（<code>spring.cloud.gateway.filter.local-response-cache.enabled</code>），它就会运行，并为所有符合以下条件的响应激活一个本地缓存。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求是一个无body的 GET。</p>
</li>
<li>
<p>响应具有以下状态代码之一。HTTP 200 (OK), HTTP 206 (Partial Content), 或 HTTP 301 (Moved Permanently)。</p>
</li>
<li>
<p>HTTP <code>Cache-Control</code> 头允许缓存（这意味着它没有以下任何值。在请求中出现 <code>no-store</code>，在响应中出现 <code>no-store</code> 或 <code>private</code>）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它接受两个配置参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.gateway.filter.local-response-cache.size</code>。设置该路由驱逐条目的最大缓存大小（单位：KB、MB 和 GB）。</p>
</li>
<li>
<p><code>spring.cloud.gateway.filter.local-response-cache.timeToLive</code>。设置缓存条目过期的时间（用 s 表示秒、m 表示分钟、h 表示小时）。如果没有配置这些参数，但启用了全局过滤器，默认情况下，它为缓存的响应配置了5分钟的生存时间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个 filter 还实现了自动计算 HTTP <code>Cache-Control</code> 头中的 <code>max-age</code> 值。如果原始响应中存在 <code>max-age</code>，则该值会以 <code>timeToLive</code> 配置参数中设置的秒数重写。在随后的调用中，这个值会以响应过期前的剩余秒数重新计算。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
如果你的项目创建了自定义的 <code>CacheManager</code> Bean，它需要用 <code>@Primary</code> 来标记，或者用 <code>@Qualifier</code> 来注入。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="forward-routing-filter"><a class="anchor" href="#forward-routing-filter"></a><a class="link" href="#forward-routing-filter">7.4. Forward Routing Filter</a></h3>
<div class="paragraph">
<p><code>ForwardRoutingFilter</code> 在 exchange 属性 <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 中寻找一个URI。如果URL有一个 forward scheme（如 <code>forward:///localendpoint</code>），它就使用 Spring <code>DispatcherHandler</code> 来处理请求。请求URL的路径部分被前向URL中的路径所覆盖。未修改的原始URL被追加到 <code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code> 属性的列表中。</p>
</div>
</div>
<div class="sect2">
<h3 id="netty-routing-filter"><a class="anchor" href="#netty-routing-filter"></a><a class="link" href="#netty-routing-filter">7.5. Netty Routing Filter</a></h3>
<div class="paragraph">
<p>如果位于 <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange 属性中的URL有一个 <code>http</code> 或 <code>https</code> scheme，Netty 路由过滤器就会运行。它使用Netty <code>HttpClient</code> 来进行下游代理请求。响应被放在 <code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code> exchange 属性中，供以后的过滤器使用。(还有一个实验性的 <code>WebClientHttpRoutingFilter</code>，执行同样的功能，但不需要 Netty。)</p>
</div>
</div>
<div class="sect2">
<h3 id="netty-write-response-filter"><a class="anchor" href="#netty-write-response-filter"></a><a class="link" href="#netty-write-response-filter">7.6. Netty Write Response Filter</a></h3>
<div class="paragraph">
<p>如果在 <code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code> exchange 属性中有一个 Netty <code>HttpClientResponse</code>，<code>NettyWriteResponseFilter</code> 就会运行。它在所有其他过滤器完成后运行，并将代理响应写回网关客户端响应。(还有一个实验性的 <code>WebClientWriteResponseFilter</code>，执行同样的功能，但不需要 Netty。)</p>
</div>
</div>
<div class="sect2">
<h3 id="reactive-loadbalancer-client-filter"><a class="anchor" href="#reactive-loadbalancer-client-filter"></a><a class="link" href="#reactive-loadbalancer-client-filter">7.7. <code>ReactiveLoadBalancerClientFilter</code></a></h3>
<div class="paragraph">
<p><code>ReactiveLoadBalancerClientFilter</code> 在名为 <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 的 exchange 属性中寻找一个URI。如果URL有一个 <code>lb</code> scheme（如 <code>lb://myservice</code>），它将使用Spring Cloud <code>ReactorLoadBalancer</code> 将名称（本例中为 <code>myservice</code>）解析为实际的主机和端口，并替换同一属性中的URI。未修改的原始URL被追加到 <code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code> 属性的列表中。过滤器也会在 <code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code> 属性中查看是否等于 <code>lb</code>，如果是，同样的规则也适用。下面的列表配置了一个 <code>ReactiveLoadBalancerClientFilter</code>。</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">myRoute</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/service/**</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
默认情况下，当 <code>ReactorLoadBalancer</code> 无法找到一个服务实例时，会返回 <code>503</code>。你可以通过设置 <code>spring.cloud.gateway.loadbalancer.use404=true</code>，将网关配置为返回 <code>404</code>。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从 <code>ReactiveLoadBalancerClientFilter</code> 返回的 <code>ServiceInstance</code> 的 <code>isSecure</code> 值覆盖了向网关发出的请求中指定的scheme。例如，如果请求通过 <code>HTTPS</code> 进入Gateway，但 <code>ServiceInstance</code> 表示它不安全，那么下游请求将通过 <code>HTTP</code> 进行。相反的情况也可以适用。然而，如果在网关配置中为路由指定了  <code>GATEWAY_SCHEME_PREFIX_ATTR</code>，那么前缀将被剥离，来自路由 URL 的结果scheme将覆盖 <code>ServiceInstance</code> 的配置。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Gateway 支持所有的 <code>LoadBalancer</code> 功能。你可以在 <a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer">Spring Cloud Commons 文档</a>中阅读更多关于它们的信息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="routetorequesturl-filter"><a class="anchor" href="#routetorequesturl-filter"></a><a class="link" href="#routetorequesturl-filter">7.8. <code>RouteToRequestUrl</code> Filter</a></h3>
<div class="paragraph">
<p>如果在 <code>ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR</code> exchange 属性中有一个 <code>Route</code> 对象，<code>RouteToRequestUrlFilter</code> 会运行。它创建了一个新的URI，基于请求URI，但用 <code>Route</code> 对象的URI属性进行更新。新的URI被放在 <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange 属性中。</p>
</div>
<div class="paragraph">
<p>如果URI有一个scheme 前缀（prefix），比如 <code>lb:ws://serviceid</code>，<code>lb</code> scheme就会从URI中剥离出来，放在 <code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code> 中，以便以后在过滤器链中使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-routing-filter"><a class="anchor" href="#websocket-routing-filter"></a><a class="link" href="#websocket-routing-filter">7.9. Websocket Routing Filter</a></h3>
<div class="paragraph">
<p>如果位于 <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange 属性中的URL有 <code>ws</code> 或 <code>wss</code> scheme，则运行 websocket 路由过滤器。它使用Spring WebSocket 基础设施将 websocket 请求转发到下游。</p>
</div>
<div class="paragraph">
<p>你可以通过给URI加上 <code>lb</code> 的前缀来实现websockets的负载均衡，比如 <code>lb:ws://serviceid</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用 <a href="https://github.com/sockjs">SockJS</a> 作为普通HTTP的后备方案，你应该配置一个普通的HTTP路由以及websocket路由。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面配置了一个websocket路由过滤器。</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-comment"># SockJS route</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">websocket_sockjs_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3001</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/websocket/info/**</span>
      <span class="hljs-comment"># Normal Websocket route</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">websocket_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">ws://localhost:3001</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/websocket/**</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="标记-exchange-为已路由"><a class="anchor" href="#%E6%A0%87%E8%AE%B0-exchange-%E4%B8%BA%E5%B7%B2%E8%B7%AF%E7%94%B1"></a><a class="link" href="#%E6%A0%87%E8%AE%B0-exchange-%E4%B8%BA%E5%B7%B2%E8%B7%AF%E7%94%B1">7.10. 标记 exchange 为已路由</a></h3>
<div class="paragraph">
<p>在网关路由了一个 <code>ServerWebExchange</code> 后，它通过在 exchange 属性中添加 <code>gatewayAlreadyRouted</code> 来标记该交换为 “routed” 。一旦一个请求被标记为已路由，其他路由过滤器就不会再对该请求进行路由，基本上是跳过过滤器。有一些方便的方法，你可以用来标记一个 exchange 为已路由，或者检查一个 exchange 是否已经被路由。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServerWebExchangeUtils.isAlreadyRouted</code> 接收一个 <code>ServerWebExchange</code>  对象并检查它是否已经被 "路由"。</p>
</li>
<li>
<p><code>ServerWebExchangeUtils.setAlreadyRouted</code> 接收一个 <code>ServerWebExchange</code> 对象并将其标记为 "已路由"。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="httpheadersfilter"><a class="anchor" href="#httpheadersfilter"></a><a class="link" href="#httpheadersfilter">8. HttpHeadersFilter</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>HttpHeadersFilter</code> 在向下游发送请求之前被应用于请求，例如在 <code>NettyRoutingFilter</code>。</p>
</div>
<div class="sect2">
<h3 id="forwarded-headers-filter"><a class="anchor" href="#forwarded-headers-filter"></a><a class="link" href="#forwarded-headers-filter">8.1. Forwarded Headers Filter</a></h3>
<div class="paragraph">
<p><code>Forwarded</code> Headers Filter 创建一个 <code>Forwarded</code> header来发送给下游服务。它将当前请求的 <code>Host</code> header、scheme和port添加到任何现有的 <code>Forwarded</code> 头中。</p>
</div>
</div>
<div class="sect2">
<h3 id="removehopbyhop-headers-filter"><a class="anchor" href="#removehopbyhop-headers-filter"></a><a class="link" href="#removehopbyhop-headers-filter">8.2. RemoveHopByHop Headers Filter</a></h3>
<div class="paragraph">
<p><code>RemoveHopByHop</code> Headers Filter 从转发的请求中移除header信息。被移除的header信息的默认列表来自 <a href="https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3">IETF</a>。</p>
</div>
<div class="ulist">
<div class="title">默认删除的header是：</div>
<ul>
<li>
<p>Connection</p>
</li>
<li>
<p>Keep-Alive</p>
</li>
<li>
<p>Proxy-Authenticate</p>
</li>
<li>
<p>Proxy-Authorization</p>
</li>
<li>
<p>TE</p>
</li>
<li>
<p>Trailer</p>
</li>
<li>
<p>Transfer-Encoding</p>
</li>
<li>
<p>Upgrade</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要改变这一点，请将 <code>spring.cloud.gateway.filter.remove-hop-by-hop.headers</code> 属性设置为要删除的 header 名称列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="xforwarded-headers-filter"><a class="anchor" href="#xforwarded-headers-filter"></a><a class="link" href="#xforwarded-headers-filter">8.3. XForwarded Headers Filter</a></h3>
<div class="paragraph">
<p><code>XForwarded</code> Headers Filter 创建各种 <code>X-Forwarded-*</code> 头，以发送到下游的服务。它使用当前请求的 <code>Host</code> header、scheme、port 和路径来创建各种 header。</p>
</div>
<div class="paragraph">
<p>创建单个 header 可以由以下布尔属性控制（默认为 true）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.gateway.x-forwarded.for-enabled</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.host-enabled</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.port-enabled</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.proto-enabled</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.prefix-enabled</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>附加多个 header 可以由以下布尔属性控制（默认为 true）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.gateway.x-forwarded.for-append</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.host-append</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.port-append</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.proto-append</code></p>
</li>
<li>
<p><code>spring.cloud.gateway.x-forwarded.prefix-append</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tls-和-ssl"><a class="anchor" href="#tls-%E5%92%8C-ssl"></a><a class="link" href="#tls-%E5%92%8C-ssl">9. TLS 和 SSL</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>网关可以通过遵循通常的 Spring server configuration 来监听 HTTPS 请求。下面的例子显示了如何做到这一点。</p>
</div>
<div class="exampleblock">
<div class="title">Example 67. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">ssl:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">key-alias:</span> <span class="hljs-string">scg</span>
    <span class="hljs-attr">key-store-password:</span> <span class="hljs-string">scg1234</span>
    <span class="hljs-attr">key-store:</span> <span class="hljs-string">classpath:scg-keystore.p12</span>
    <span class="hljs-attr">key-store-type:</span> <span class="hljs-string">PKCS12</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以将网关路由到HTTP和HTTPS后端。如果你要路由到HTTPS后端，你可以通过以下配置将网关配置为信任所有下游的证书。</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">httpclient:</span>
        <span class="hljs-attr">ssl:</span>
          <span class="hljs-attr">useInsecureTrustManager:</span> <span class="hljs-literal">true</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用不安全的 trust manager 不适合于生产。对于生产部署，你可以用一组已知的证书来配置网关，它可以通过以下配置来信任。</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">httpclient:</span>
        <span class="hljs-attr">ssl:</span>
          <span class="hljs-attr">trustedX509Certificates:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">cert1.pem</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">cert2.pem</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果 Spring Cloud Gateway 没有配置受信任的证书，就会使用默认的 trust store（你可以通过设置 <code>javax.net.ssl.trustStore</code> 系统属性来覆盖它）。</p>
</div>
<div class="sect2">
<h3 id="tls-握手"><a class="anchor" href="#tls-%E6%8F%A1%E6%89%8B"></a><a class="link" href="#tls-%E6%8F%A1%E6%89%8B">9.1. TLS 握手</a></h3>
<div class="paragraph">
<p>网关维护着一个client pool，它用来路由到后端。当通过HTTPS进行通信时，客户端发起了一个TLS握手。一些 timeout 配置与这个握手相关。你可以对这些 timeouts 进行配置，如下（默认值）。</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">httpclient:</span>
        <span class="hljs-attr">ssl:</span>
          <span class="hljs-attr">handshake-timeout-millis:</span> <span class="hljs-number">10000</span>
          <span class="hljs-attr">close-notify-flush-timeout-millis:</span> <span class="hljs-number">3000</span>
          <span class="hljs-attr">close-notify-read-timeout-millis:</span> <span class="hljs-number">0</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="配置configuration"><a class="anchor" href="#%E9%85%8D%E7%BD%AEconfiguration"></a><a class="link" href="#%E9%85%8D%E7%BD%AEconfiguration">10. 配置（Configuration）</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Gateway 的配置是由 <code>RouteDefinitionLocator</code> 实例的集合驱动的。下面的列表显示了 <code>RouteDefinitionLocator</code> 接口的定义。</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. RouteDefinitionLocator.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RouteDefinitionLocator</span> </span>{
    <span class="hljs-function">Flux&lt;RouteDefinition&gt; <span class="hljs-title">getRouteDefinitions</span><span class="hljs-params">()</span></span>;
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>PropertiesRouteDefinitionLocator</code> 通过使用Spring Boot的 <code>@ConfigurationProperties</code> 机制加载属性。</p>
</div>
<div class="paragraph">
<p>前面的配置例子都使用了一种快捷方式，即使用位置参数而不是命名参数。下面的两个例子是等价的。</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setstatus_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SetStatus</span>
          <span class="hljs-attr">args:</span>
            <span class="hljs-attr">status:</span> <span class="hljs-number">401</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">setstatusshortcut_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">filters:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=401</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于网关的某些用途来说，属性已经足够了，但一些生产用例会从外部来源（如数据库）加载配置中受益。未来的里程碑版本将有基于 Spring Data Repository 的 <code>RouteDefinitionLocator</code> 实现，如 Redis、MongoDB和Cassandra。</p>
</div>
<div class="sect2">
<h3 id="routedefinition-指标"><a class="anchor" href="#routedefinition-%E6%8C%87%E6%A0%87"></a><a class="link" href="#routedefinition-%E6%8C%87%E6%A0%87">10.1. RouteDefinition 指标</a></h3>
<div class="paragraph">
<p>要启用 <code>RouteDefinition</code> 指标，请添加 <code>spring-boot-starter-actuator</code> 依赖。然后，默认情况下，只要 <code>spring.cloud.gateway.metrics.enabled</code> 属性被设置为 <code>true</code>，这些指标就会可用。将添加一个名为 <code>spring.cloud.gateway.routes.count</code> 的指标，其值是 <code>RouteDefinitions</code> 的数量。这个指标将从 <code>/actuator/metrics/spring.cloud.gateway.routes.count</code> 中获得。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="路由元数据配置"><a class="anchor" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE"></a><a class="link" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE">11. 路由元数据配置</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以通过使用元数据为每个路由配置额外的参数，如下所示。</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">route_with_metadata</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">metadata:</span>
          <span class="hljs-attr">optionName:</span> <span class="hljs-string">"OptionValue"</span>
          <span class="hljs-attr">compositeObject:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">"value"</span>
          <span class="hljs-attr">iAmNumber:</span> <span class="hljs-number">1</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以从一个 exchange 所获取所有的元数据属性，如下所示</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="hljs gradle">Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
<span class="hljs-comment">// get all metadata properties</span>
route.getMetadata();
<span class="hljs-comment">// get a single metadata property</span>
route.getMetadata(someKey);</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="http超时timeout配置"><a class="anchor" href="#http%E8%B6%85%E6%97%B6timeout%E9%85%8D%E7%BD%AE"></a><a class="link" href="#http%E8%B6%85%E6%97%B6timeout%E9%85%8D%E7%BD%AE">12. Http超时（timeout）配置</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以为所有路由配置Http超时（响应和连接），也可以为每个特定的路由重写。</p>
</div>
<div class="sect2">
<h3 id="全局-timeout"><a class="anchor" href="#%E5%85%A8%E5%B1%80-timeout"></a><a class="link" href="#%E5%85%A8%E5%B1%80-timeout">12.1. 全局 timeout</a></h3>
<div class="paragraph">
<p>要配置全局http超时。
 <code>connect-timeout</code> 必须以毫秒为单位指定。
响应超时必须以 <code>java.time.Duration</code> 的形式指定。</p>
</div>
<div class="listingblock">
<div class="title">global http timeouts example</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">httpclient:</span>
        <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">1000</span>
        <span class="hljs-attr">response-timeout:</span> <span class="hljs-string">5s</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="每个路由的-timeout"><a class="anchor" href="#%E6%AF%8F%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84-timeout"></a><a class="link" href="#%E6%AF%8F%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84-timeout">12.2. 每个路由的 timeout</a></h3>
<div class="paragraph">
<p>要配置每个路由的超时。
 <code>connect-timeout</code> 必须以毫秒为单位指定。
<code>response-timeout</code> 必须以毫秒为单位指定。</p>
</div>
<div class="listingblock">
<div class="title">per-route http timeouts configuration via configuration</div>
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml">      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">per_route_timeouts</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Path</span>
            <span class="hljs-attr">args:</span>
              <span class="hljs-attr">pattern:</span> <span class="hljs-string">/delay/{timeout}</span>
        <span class="hljs-attr">metadata:</span>
          <span class="hljs-attr">response-timeout:</span> <span class="hljs-number">200</span>
          <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">200</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="listingblock">
<div class="title">per-route timeouts configuration using Java DSL</div>
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="fold-block hide-when-folded"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.cloud.gateway.support.RouteMetadataUtils.CONNECT_TIMEOUT_ATTR;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.cloud.gateway.support.RouteMetadataUtils.RESPONSE_TIMEOUT_ATTR;

</span><span class="fold-block">      <span class="hljs-meta">@Bean</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">customRouteLocator</span><span class="hljs-params">(RouteLocatorBuilder routeBuilder)</span></span>{
         <span class="hljs-keyword">return</span> routeBuilder.routes()
               .route(<span class="hljs-string">"test1"</span>, r -&gt; {
                  <span class="hljs-keyword">return</span> r.host(<span class="hljs-string">"*.somehost.org"</span>).and().path(<span class="hljs-string">"/somepath"</span>)
                        .filters(f -&gt; f.addRequestHeader(<span class="hljs-string">"header1"</span>, <span class="hljs-string">"header-value-1"</span>))
                        .uri(<span class="hljs-string">"http://someuri"</span>)
                        .metadata(RESPONSE_TIMEOUT_ATTR, <span class="hljs-number">200</span>)
                        .metadata(CONNECT_TIMEOUT_ATTR, <span class="hljs-number">200</span>);
               })
               .build();
      }
</span></code><div class="codetools"><button class="undefined unfold-button" title="Expanded folded text" type="button"><span class="label">Expanded folded text</span></button><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="paragraph">
<p>路由的 <code>response-timeout</code> 为负值，将禁用全局 <code>response-timeout</code>  值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      - id: per_route_timeouts
        uri: https://example.org
        predicates:
          - name: Path
            args:
              pattern: /delay/{timeout}
        metadata:
          response-timeout: -1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="route-的fluent式-java-api"><a class="anchor" href="#route-%E7%9A%84fluent%E5%BC%8F-java-api"></a><a class="link" href="#route-%E7%9A%84fluent%E5%BC%8F-java-api">12.3. Route 的Fluent式 Java API</a></h3>
<div class="paragraph">
<p>为了允许在Java中进行简单的配置，<code>RouteLocatorBuilder</code> Bean包括一个fluent API。下面的列表显示了它是如何工作的。</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. GatewaySampleApplication.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-comment">// static imports from GatewayFilters and RoutePredicates</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">customRouteLocator</span><span class="hljs-params">(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle)</span> </span>{
    <span class="hljs-keyword">return</span> builder.routes()
            .route(r -&gt; r.host(<span class="hljs-string">"**.abc.org"</span>).and().path(<span class="hljs-string">"/image/png"</span>)
                .filters(f -&gt;
                        f.addResponseHeader(<span class="hljs-string">"X-TestHeader"</span>, <span class="hljs-string">"foobar"</span>))
                .uri(<span class="hljs-string">"http://httpbin.org:80"</span>)
            )
            .route(r -&gt; r.path(<span class="hljs-string">"/image/webp"</span>)
                .filters(f -&gt;
                        f.addResponseHeader(<span class="hljs-string">"X-AnotherHeader"</span>, <span class="hljs-string">"baz"</span>))
                .uri(<span class="hljs-string">"http://httpbin.org:80"</span>)
                .metadata(<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>)
            )
            .route(r -&gt; r.order(-<span class="hljs-number">1</span>)
                .host(<span class="hljs-string">"**.throttle.org"</span>).and().path(<span class="hljs-string">"/get"</span>)
                .filters(f -&gt; f.filter(throttle.apply(<span class="hljs-number">1</span>,
                        <span class="hljs-number">1</span>,
                        <span class="hljs-number">10</span>,
                        TimeUnit.SECONDS)))
                .uri(<span class="hljs-string">"http://httpbin.org:80"</span>)
                .metadata(<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>)
            )
            .build();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种风格也允许更多的自定义谓词断言。<code>RouteDefinitionLocator</code> bean 类定义的谓词使用逻辑 <code>and</code> 来组合。通过使用fluent Java API，你可以在 <code>Predicate</code> 类上使用 <code>and()</code>、<code>or()</code> 和 <code>negate()</code> 操作符。</p>
</div>
</div>
<div class="sect2">
<h3 id="discoveryclient-路由服务的注册与发现"><a class="anchor" href="#discoveryclient-%E8%B7%AF%E7%94%B1%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"></a><a class="link" href="#discoveryclient-%E8%B7%AF%E7%94%B1%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0">12.4. <code>DiscoveryClient</code> 路由服务的注册与发现</a></h3>
<div class="paragraph">
<p>你可以将网关配置为基于在 <code>DiscoveryClient</code> 兼容服务注册中心上注册的服务来创建路由。</p>
</div>
<div class="paragraph">
<p>要启用这一点，请设置 <code>spring.cloud.gateway.discovery.locator.enabled=true</code> 并确保 <code>DiscoveryClient</code> 实现（如 Netflix Eureka、Consul 或 Zookeeper）位于 classpath 上并已启用。</p>
</div>
<div class="sect3">
<h4 id="为-discoveryclient-路由配置谓词和过滤器"><a class="anchor" href="#%E4%B8%BA-discoveryclient-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E8%B0%93%E8%AF%8D%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"></a><a class="link" href="#%E4%B8%BA-discoveryclient-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E8%B0%93%E8%AF%8D%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8">12.4.1. 为 <code>DiscoveryClient</code> 路由配置谓词和过滤器</a></h4>
<div class="paragraph">
<p>默认情况下，网关为用 <code>DiscoveryClient</code> 创建的路由定义了一个谓词和过滤器。</p>
</div>
<div class="paragraph">
<p>默认谓词是用 <code>/serviceId/**</code> pattern 定义的路径谓词，其中 <code>serviceId</code> 是来自 <code>DiscoveryClient</code> 的服务的 <code>ID</code>。</p>
</div>
<div class="paragraph">
<p>默认的过滤器是一个重写路径过滤器，使用 regex <code>/serviceId/?(?&lt;remaining&gt;.*)</code> 和替换词 <code>/${remaining}</code>。这在请求被发送到下游之前从路径中剥离了服务ID。</p>
</div>
<div class="paragraph">
<p>如果你想定制 <code>DiscoveryClient</code> 路由使用的谓词或过滤器，请设置 <code>spring.cloud.gateway.discovery.locator.predicates[x]</code> 和 <code>spring.cloud.gateway.discovery.locator.filters[y]</code>。这样做时，如果你想保留该功能，你需要确保包括前面显示的默认谓词和过滤器。下面的例子显示了这是什么样子。</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. application.properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>spring.cloud.gateway.discovery.locator.predicates[0].name: Path
spring.cloud.gateway.discovery.locator.predicates[0].args[pattern]: "'/'+serviceId+'/**'"
spring.cloud.gateway.discovery.locator.predicates[1].name: Host
spring.cloud.gateway.discovery.locator.predicates[1].args[pattern]: "'**.foo.com'"
spring.cloud.gateway.discovery.locator.filters[0].name: CircuitBreaker
spring.cloud.gateway.discovery.locator.filters[0].args[name]: serviceId
spring.cloud.gateway.discovery.locator.filters[1].name: RewritePath
spring.cloud.gateway.discovery.locator.filters[1].args[regexp]: "'/' + serviceId + '/?(?&lt;remaining&gt;.*)'"
spring.cloud.gateway.discovery.locator.filters[1].args[replacement]: "'/${remaining}'"</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactor-netty-访问日志"><a class="anchor" href="#reactor-netty-%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97"></a><a class="link" href="#reactor-netty-%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97">13. Reactor Netty 访问日志</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>要启用 Reactor Netty 访问日志，请设置 <code>-Dreactor.netty.http.server.accessLogEnabled=true</code>。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
它必须是一个 Java System Property，而不是一个Spring Boot属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>你可以配置日志系统，使其有一个单独的访问日志文件。下面的例子创建了一个Logback配置。</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. logback.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml hljs" data-lang="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"accessLog"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.FileAppender"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>access_log.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"async"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"accessLog"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reactor.netty.http.server.AccessLog"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">"false"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"async"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cors-配置"><a class="anchor" href="#cors-%E9%85%8D%E7%BD%AE"></a><a class="link" href="#cors-%E9%85%8D%E7%BD%AE">14. CORS 配置</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以配置网关来控制全局或每个路由的 CORS 行为。两者都提供同样的可能性。</p>
</div>
<div class="sect2">
<h3 id="global-cors-配置"><a class="anchor" href="#global-cors-%E9%85%8D%E7%BD%AE"></a><a class="link" href="#global-cors-%E9%85%8D%E7%BD%AE">14.1. Global CORS 配置</a></h3>
<div class="paragraph">
<p>“global” CORS配置是对 <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html">Spring Framework <code>CorsConfiguration</code></a> 的URL模式的映射。下面的例子配置了 CORS。</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">globalcors:</span>
        <span class="hljs-attr">cors-configurations:</span>
          <span class="hljs-string">'[/**]'</span><span class="hljs-string">:</span>
            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-string">"https://docs.spring.io"</span>
            <span class="hljs-attr">allowedMethods:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中，对于所有GET请求的路径，允许来自 <code>docs.spring.io</code> 的请求的CORS请求。</p>
</div>
<div class="paragraph">
<p>要为未被某些网关路由谓词处理的请求提供相同的 CORS 配置，请将 <code>spring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping</code> 属性设为 <code>true</code>。当你试图支持 CORS 预检请求，而你的路由谓词因为 HTTP 方法是 <code>options</code> 而不能评估为 <code>true</code> 时，这很有用。</p>
</div>
</div>
<div class="sect2">
<h3 id="路由的-cors-配置"><a class="anchor" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-cors-%E9%85%8D%E7%BD%AE"></a><a class="link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-cors-%E9%85%8D%E7%BD%AE">14.2. 路由的 CORS 配置</a></h3>
<div class="paragraph">
<p>“route” configuration 允许将CORS直接应用于带有key <code>CORS</code> 的路由作为元数据。像全局配置一样，这些属性属于 <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html">Spring Framework <code>CorsConfiguration</code></a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果路由中没有 <code>Path</code> 谓词，则将应用 '/**'。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">Example 78. application.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml hljs" data-lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cors_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/service/**</span>
        <span class="hljs-attr">metadata:</span>
          <span class="hljs-string">cors</span>
            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-string">'*'</span>
            <span class="hljs-attr">allowedMethods:</span>
              <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span>
              <span class="hljs-bullet">-</span> <span class="hljs-string">POST</span>
            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">'*'</span>
            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">30</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="actuator-api"><a class="anchor" href="#actuator-api"></a><a class="link" href="#actuator-api">15. Actuator API</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过 <code>/gateway</code> 执行器端点，你可以监控并与 Spring Cloud Gateway 应用进行互动。要进行远程访问，端点必须在应用程序属性中 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints">enabled</a> 并 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints">通过HTTP或JMX暴露</a>。下面的列表显示了如何做到这一点。</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. application.properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-properties hljs" data-lang="properties"><span class="hljs-meta">management.endpoint.gateway.enabled</span>=<span class="hljs-string">true # default value</span>
<span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">gateway</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="冗长的-actuator-格式"><a class="anchor" href="#%E5%86%97%E9%95%BF%E7%9A%84-actuator-%E6%A0%BC%E5%BC%8F"></a><a class="link" href="#%E5%86%97%E9%95%BF%E7%9A%84-actuator-%E6%A0%BC%E5%BC%8F">15.1. 冗长的 Actuator 格式</a></h3>
<div class="paragraph">
<p>在Spring Cloud Gateway中增加了一种新的、更啰嗦的格式。它为每个路由添加了更多细节，让你查看与每个路由相关的谓词和过滤器，以及任何可用的配置。下面的例子配置了 <code>/actuator/gateway/routes</code>。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json hljs" data-lang="json">[
  {
    <span class="hljs-attr">"predicate"</span>: <span class="hljs-string">"(Hosts: [**.addrequestheader.org] &amp;&amp; Paths: [/headers], match trailing slash: true)"</span>,
    <span class="hljs-attr">"route_id"</span>: <span class="hljs-string">"add_request_header_test"</span>,
    <span class="hljs-attr">"filters"</span>: [
      <span class="hljs-string">"[[AddResponseHeader X-Response-Default-Foo = 'Default-Bar'], order = 1]"</span>,
      <span class="hljs-string">"[[AddRequestHeader X-Request-Foo = 'Bar'], order = 1]"</span>,
      <span class="hljs-string">"[[PrefixPath prefix = '/httpbin'], order = 2]"</span>
    ],
    <span class="hljs-attr">"uri"</span>: <span class="hljs-string">"lb://testservice"</span>,
    <span class="hljs-attr">"order"</span>: <span class="hljs-number">0</span>
  }
]</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个功能默认是启用的。要禁用它，请设置以下属性。</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. application.properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-properties hljs" data-lang="properties"><span class="hljs-meta">spring.cloud.gateway.actuator.verbose.enabled</span>=<span class="hljs-string">false</span></code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在未来的版本中，这将默认为 <code>true</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="检索路由过滤器"><a class="anchor" href="#%E6%A3%80%E7%B4%A2%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8"></a><a class="link" href="#%E6%A3%80%E7%B4%A2%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8">15.2. 检索路由过滤器</a></h3>
<div class="paragraph">
<p>本节详细介绍了如何检索路由过滤器，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gateway-global-filters">全局过滤器（Global Filter）</a></p>
</li>
<li>
<p><a href="#gateway-route-filters">[gateway-route-filters]</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="gateway-global-filters"><a class="anchor" href="#gateway-global-filters"></a><a class="link" href="#gateway-global-filters">15.2.1. 全局过滤器（Global Filter）</a></h4>
<div class="paragraph">
<p>要检索应用于所有路由的 <a href="#global-filters">全局过滤器</a>，请向 <code>/actuator/gateway/globalfilters</code> 发出一个GET请求。得到的响应类似于以下内容。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>{
  "org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5": 10100,
  "org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@4f6fd101": 10000,
  "org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@32d22650": -1,
  "org.springframework.cloud.gateway.filter.ForwardRoutingFilter@106459d9": 2147483647,
  "org.springframework.cloud.gateway.filter.NettyRoutingFilter@1fbd5e0": 2147483647,
  "org.springframework.cloud.gateway.filter.ForwardPathFilter@33a71d23": 0,
  "org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@135064ea": 2147483637,
  "org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@23c05889": 2147483646
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>响应包含全局过滤器的细节，这些过滤器已经到位。对于每个全局过滤器，有一个过滤器对象的字符串表示（例如，<code>org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5</code>）以及过滤器链中的相应 <a href="#gateway-combined-global-filter-and-gatewayfilter-ordering">顺序</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="gateway-route-filters"><a class="anchor" href="#gateway-route-filters"></a><a class="link" href="#gateway-route-filters">15.2.2. 路由过滤器（Route Filter）</a></h4>
<div class="paragraph">
<p>要检索应用于路由的 <a href="#gatewayfilter-factories"><code>GatewayFilter</code> 工厂</a>，请向 <code>/actuator/gateway/routefilters</code> 发出一个 <code>GET</code> 请求。得到的响应类似于以下内容。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>{
  "[AddRequestHeaderGatewayFilterFactory@570ed9c configClass = AbstractNameValueGatewayFilterFactory.NameValueConfig]": null,
  "[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]": null,
  "[SaveSessionGatewayFilterFactory@4449b273 configClass = Object]": null
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>响应包含应用于任何特定路由的 <code>GatewayFilter</code> 工厂的细节。对于每个工厂，有一个相应对象的字符串表示（例如，<code>[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]</code>）。请注意，<code>nul</code> 是由于 endpoint controller 的不完整实现，因为它试图设置过滤器链中的对象的顺序，这不适用于 <code>GatewayFilter</code> 工厂对象。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="刷新路由缓存"><a class="anchor" href="#%E5%88%B7%E6%96%B0%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98"></a><a class="link" href="#%E5%88%B7%E6%96%B0%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98">15.3. 刷新路由缓存</a></h3>
<div class="paragraph">
<p>要清除路由缓存，请向 <code>/actuator/gateway/refresh</code> 发出一个 <code>POST</code> 请求。该请求返回一个200，没有响应体。</p>
</div>
</div>
<div class="sect2">
<h3 id="检索网关中自定义的路由"><a class="anchor" href="#%E6%A3%80%E7%B4%A2%E7%BD%91%E5%85%B3%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B7%AF%E7%94%B1"></a><a class="link" href="#%E6%A3%80%E7%B4%A2%E7%BD%91%E5%85%B3%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B7%AF%E7%94%B1">15.4. 检索网关中自定义的路由</a></h3>
<div class="paragraph">
<p>要检索网关中定义的路由，请向 <code>/actuator/gateway/routes</code> 发出一个 <code>GET</code> 请求。得到的响应类似于以下内容。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>[{
  "route_id": "first_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@1e9d7e7d",
    "filters": [
      "OrderedGatewayFilter{delegate=org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactory$$Lambda$436/674480275@6631ef72, order=0}"
    ]
  },
  "order": 0
},
{
  "route_id": "second_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@cd8d298",
    "filters": []
  },
  "order": 0
}]</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>响应包含网关中定义的所有路由的详细信息。下表描述了响应中每个元素的结构（每个都是一个路由）。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 22.2222%;">
<col style="width: 44.4445%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>route_id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由 ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>route_object.predicate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由的 predicate。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>route_object.filters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用于路由的 <a href="#gatewayfilter-factories"><code>GatewayFilter</code> 工厂</a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由顺序。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="gateway-retrieving-information-about-a-particular-route"><a class="anchor" href="#gateway-retrieving-information-about-a-particular-route"></a><a class="link" href="#gateway-retrieving-information-about-a-particular-route">15.5. 检索指定的路由</a></h3>
<div class="paragraph">
<p>要检索一条路由的信息，请向 <code>/actuator/gateway/routes/{id}</code> 发出一个 <code>GET</code> 请求（例如，<code>/actuator/gateway/routes/first_route</code>）。得到的响应类似于下面的内容。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>{
  "id": "first_route",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"/first"}
  }],
  "filters": [],
  "uri": "https://www.uri-destination.org",
  "order": 0
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下表描述了响应的结构。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 22.2222%;">
<col style="width: 44.4445%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由 ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>predicates</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由谓词的集合。每一项都定义了谓词的名称和参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>filters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用于路由的Filter集合。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由的目的地URI。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由的Order。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="创建和删除一个指定的路由"><a class="anchor" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E7%94%B1"></a><a class="link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E7%94%B1">15.6. 创建和删除一个指定的路由</a></h3>
<div class="paragraph">
<p>要创建一个路由，请向 <code>/gateway/routes/{id_route_to_create}</code> 发出一个 <code>POST</code> 请求，该请求包含一个指定路由字段的JSON BODY（见 <a href="#gateway-retrieving-information-about-a-particular-route">检索指定的路由</a>）。</p>
</div>
<div class="paragraph">
<p>要删除一条路由，请向 <code>/gateway/routes/{id_route_to_delete}</code> 发出 <code>DELETE</code> 请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="回顾所有端点列表"><a class="anchor" href="#%E5%9B%9E%E9%A1%BE%E6%89%80%E6%9C%89%E7%AB%AF%E7%82%B9%E5%88%97%E8%A1%A8"></a><a class="link" href="#%E5%9B%9E%E9%A1%BE%E6%89%80%E6%9C%89%E7%AB%AF%E7%82%B9%E5%88%97%E8%A1%A8">15.7. 回顾：所有端点列表</a></h3>
<div class="paragraph">
<p>下面的表格总结了 Spring Cloud Gateway 的执行器（actuator）端点（注意，每个端点都有 <code>/actuator/gateway</code> 作为基本路径）。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">HTTP Method</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>globalfilters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用于路由的全局过滤器的列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routefilters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用于特定路由的 <code>GatewayFilter</code> 工厂的列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refresh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">清除路由缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示网关中定义的路由列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示指定路由的信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加一个新的路由到网关。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从网关删除一个路由。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="在多个网关实例之间共享路由"><a class="anchor" href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%BD%91%E5%85%B3%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E8%B7%AF%E7%94%B1"></a><a class="link" href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%BD%91%E5%85%B3%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E8%B7%AF%E7%94%B1">15.8. 在多个网关实例之间共享路由</a></h3>
<div class="paragraph">
<p>Spring Cloud Gateway 提供两种 <code>RouteDefinitionRepository</code> 实现。第一个是 <code>InMemoryRouteDefinitionRepository</code>，它只存在于一个 Gateway 实例的内存中。这种类型的 Repository 不适合在多个Gateway实例中填充路由。</p>
</div>
<div class="paragraph">
<p>为了在 Spring Cloud Gateway 实例的集群中共享路由，可以使用 <code>RedisRouteDefinitionRepository</code>。要启用这种 repository，必须将以下属性设置为 <code>true</code>: <code>spring.cloud.gateway.redis-route-definition-repository.enabled</code>。与 <code>RedisRateLimiter</code> 过滤器工厂一样，它需要使用 <code>spring-boot-starter-data-redis-reactive</code> Spring Boot starter。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="troubleshooting"><a class="anchor" href="#troubleshooting"></a><a class="link" href="#troubleshooting">16. 问题排查</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节涵盖了你在使用 Spring Cloud Gateway 时可能出现的常见问题。</p>
</div>
<div class="sect2">
<h3 id="日志级别"><a class="anchor" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"></a><a class="link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">16.1. 日志级别</a></h3>
<div class="paragraph">
<p>在 <code>DEBUG</code> 和 <code>TRACE</code> 级别，以下logger可能包含有价值的故障排除信息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.cloud.gateway</code></p>
</li>
<li>
<p><code>org.springframework.http.server.reactive</code></p>
</li>
<li>
<p><code>org.springframework.web.reactive</code></p>
</li>
<li>
<p><code>org.springframework.boot.autoconfigure.web</code></p>
</li>
<li>
<p><code>reactor.netty</code></p>
</li>
<li>
<p><code>redisratelimiter</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="wiretap"><a class="anchor" href="#wiretap"></a><a class="link" href="#wiretap">16.2. Wiretap</a></h3>
<div class="paragraph">
<p>Reactor Netty 的 <code>HttpClient</code> 和 <code>HttpServer</code> 可以启用 wiretap。当与 <code>reactor.netty</code> 日志级别设置为 <code>DEBUG</code> 或 <code>TRACE</code> 相结合时，它能够记录信息，例如通过路由发送和接收的header信息和body。要启用 <code>wiretap</code>，请分别为 <code>HttpServer</code> 和 <code>HttpClient</code> 设置 <code>spring.cloud.gateway.httpserver.wiretap=true</code> 或 <code>spring.cloud.gateway.httpclient.wiretap=true</code>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="开发手册"><a class="anchor" href="#%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C"></a><a class="link" href="#%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C">17. 开发手册</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>这些是编写网关的一些自定义组件的基本指南。</p>
</div>
<div class="sect2">
<h3 id="编写自定义路由route谓语predicate工厂"><a class="anchor" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1route%E8%B0%93%E8%AF%ADpredicate%E5%B7%A5%E5%8E%82"></a><a class="link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1route%E8%B0%93%E8%AF%ADpredicate%E5%B7%A5%E5%8E%82">17.1. 编写自定义路由（Route）谓语（Predicate）工厂</a></h3>
<div class="paragraph">
<p>自定义 Route Predicate，你需要提供一个实现了 <code>RoutePredicateFactory</code> 的 bean。有一个抽象的类叫做 <code>AbstractRoutePredicateFactory</code>，你可以继承它。</p>
</div>
<div class="listingblock">
<div class="title">MyRoutePredicateFactory.java</div>
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRoutePredicateFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutePredicateFactory</span>&lt;<span class="hljs-title">MyRoutePredicateFactory</span>.<span class="hljs-title">Config</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRoutePredicateFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>(Config.class);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="hljs-title">apply</span><span class="hljs-params">(Config config)</span> </span>{
        <span class="hljs-comment">// grab configuration from Config object</span>
        <span class="hljs-keyword">return</span> exchange -&gt; {
            <span class="hljs-comment">//grab the request</span>
            ServerHttpRequest request = exchange.getRequest();
            <span class="hljs-comment">//take information from the request to see if it</span>
            <span class="hljs-comment">//matches configuration.</span>
            <span class="hljs-keyword">return</span> matches(config, request);
        };
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
        <span class="hljs-comment">//Put the configuration properties for your filter here</span>
    }

}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="编写自定义-gatewayfilter-工厂"><a class="anchor" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89-gatewayfilter-%E5%B7%A5%E5%8E%82"></a><a class="link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89-gatewayfilter-%E5%B7%A5%E5%8E%82">17.2. 编写自定义 GatewayFilter 工厂</a></h3>
<div class="paragraph">
<p>自定义 <code>GatewayFilter</code>，你必须提供一个实现了 <code>GatewayFilterFactory</code> 的bean。你可以继承一个名为 <code>AbstractGatewayFilterFactory</code> 的抽象类。下面的例子展示了如何做到这一点。</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. PreGatewayFilterFactory.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGatewayFilterFactory</span>&lt;<span class="hljs-title">PreGatewayFilterFactory</span>.<span class="hljs-title">Config</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PreGatewayFilterFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>(Config.class);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title">apply</span><span class="hljs-params">(Config config)</span> </span>{
        <span class="hljs-comment">// grab configuration from Config object</span>
        <span class="hljs-keyword">return</span> (exchange, chain) -&gt; {
            <span class="hljs-comment">//If you want to build a "pre" filter you need to manipulate the</span>
            <span class="hljs-comment">//request before calling chain.filter</span>
            ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
            <span class="hljs-comment">//use builder to manipulate the request</span>
            <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().request(builder.build()).build());
        };
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
        <span class="hljs-comment">//Put the configuration properties for your filter here</span>
    }

}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PostGatewayFilterFactory.java</div>
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGatewayFilterFactory</span>&lt;<span class="hljs-title">PostGatewayFilterFactory</span>.<span class="hljs-title">Config</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PostGatewayFilterFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>(Config.class);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title">apply</span><span class="hljs-params">(Config config)</span> </span>{
        <span class="hljs-comment">// grab configuration from Config object</span>
        <span class="hljs-keyword">return</span> (exchange, chain) -&gt; {
            <span class="hljs-keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt; {
                ServerHttpResponse response = exchange.getResponse();
                <span class="hljs-comment">//Manipulate the response in some way</span>
            }));
        };
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
        <span class="hljs-comment">//Put the configuration properties for your filter here</span>
    }

}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="在配置中命名自定义-filter-和引用"><a class="anchor" href="#%E5%9C%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%91%BD%E5%90%8D%E8%87%AA%E5%AE%9A%E4%B9%89-filter-%E5%92%8C%E5%BC%95%E7%94%A8"></a><a class="link" href="#%E5%9C%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%91%BD%E5%90%8D%E8%87%AA%E5%AE%9A%E4%B9%89-filter-%E5%92%8C%E5%BC%95%E7%94%A8">17.2.1. 在配置中命名自定义 Filter 和引用</a></h4>
<div class="paragraph">
<p>自定义Filter的类名应该以 <code>GatewayFilterFactory</code> 结尾。</p>
</div>
<div class="paragraph">
<p>例如，要在配置文件中引用一个名为 <code>Something</code> 的过滤器，该过滤器必须在一个名为 <code>SomethingGatewayFilterFactory</code> 的类中。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
可以创建一个没有 <code>GatewayFilterFactory</code> 后缀的网关过滤器，如 <code>AnotherThing</code> 类。这个过滤器可以在配置文件中被引用为 <code>AnotherThing</code>。这不是一个被支持的命名惯例，这种语法可能在未来的版本中被删除。请更新过滤器的名称，使其符合要求。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="编写自定义全局过滤器"><a class="anchor" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"></a><a class="link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8">17.3. 编写自定义全局过滤器</a></h3>
<div class="paragraph">
<p>要编写一个自定义的全局过滤器，你必须提供一个实现了 <code>GlobalFilter</code> 接口的Bean。这将把过滤器应用于所有的请求。</p>
</div>
<div class="paragraph">
<p>下面的例子分别说明了如何设置全局 pre 过滤器和 post 过滤器。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> GlobalFilter <span class="hljs-title">customGlobalFilter</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> (exchange, chain) -&gt; exchange.getPrincipal()
        .map(Principal::getName)
        .defaultIfEmpty(<span class="hljs-string">"Default User"</span>)
        .map(userName -&gt; {
          <span class="hljs-comment">//adds header to proxied request</span>
          exchange.getRequest().mutate().header(<span class="hljs-string">"CUSTOM-REQUEST-HEADER"</span>, userName).build();
          <span class="hljs-keyword">return</span> exchange;
        })
        .flatMap(chain::filter);
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> GlobalFilter <span class="hljs-title">customGlobalPostFilter</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> (exchange, chain) -&gt; chain.filter(exchange)
        .then(Mono.just(exchange))
        .map(serverWebExchange -&gt; {
          <span class="hljs-comment">//adds header to response</span>
          serverWebExchange.getResponse().getHeaders().set(<span class="hljs-string">"CUSTOM-RESPONSE-HEADER"</span>,
              HttpStatus.OK.equals(serverWebExchange.getResponse().getStatusCode()) ? <span class="hljs-string">"It worked"</span>: <span class="hljs-string">"It did not work"</span>);
          <span class="hljs-keyword">return</span> serverWebExchange;
        })
        .then();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="通过使用spring-mvc或webflux构建一个简单的网关"><a class="anchor" href="#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8spring-mvc%E6%88%96webflux%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E5%85%B3"></a><a class="link" href="#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8spring-mvc%E6%88%96webflux%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E5%85%B3">18. 通过使用Spring MVC或Webflux构建一个简单的网关</a></h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
下面描述的是另一种风格的网关。之前的文档都不适用于下面的内容。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway 提供了一个名为 <code>ProxyExchange</code> 的实用对象。你可以在普通的 Spring web handler 中作为方法参数使用它。它通过反映 HTTP 动词的方法支持基本的下游 HTTP exchange。在MVC中，它还支持通过 <code>forward()</code> 方法转发到本地处理程序。要使用 <code>ProxyExchange</code>，在你的classpath中包含正确的模块（<code>spring-cloud-gateway-mvc</code> 或 <code>spring-cloud-gateway-webflux</code>）。</p>
</div>
<div class="paragraph">
<p>下面的MVC例子将一个到 <code>/test</code> 的请求代理到一个远程服务器。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewaySampleApplication</span> </span>{

    <span class="hljs-meta">@Value("${remote.home}")</span>
    <span class="hljs-keyword">private</span> URI home;

    <span class="hljs-meta">@GetMapping("/test")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; proxy(ProxyExchange&lt;<span class="hljs-keyword">byte</span>[]&gt; proxy) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> proxy.uri(home.toString() + <span class="hljs-string">"/image/png"</span>).get();
    }

}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子用Webflux实现相同的效果。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewaySampleApplication</span> </span>{

    <span class="hljs-meta">@Value("${remote.home}")</span>
    <span class="hljs-keyword">private</span> URI home;

    <span class="hljs-meta">@GetMapping("/test")</span>
    <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;?&gt;&gt; proxy(ProxyExchange&lt;<span class="hljs-keyword">byte</span>[]&gt; proxy) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> proxy.uri(home.toString() + <span class="hljs-string">"/image/png"</span>).get();
    }

}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ProxyExchange</code> 上的便利方法使处理方法能够发现并增强传入请求的URI路径。例如，你可能想提取路径的尾部元素，将它们传递到下游。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-meta">@GetMapping("/proxy/path/**")</span>
<span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; proxyPath(ProxyExchange&lt;<span class="hljs-keyword">byte</span>[]&gt; proxy) <span class="hljs-keyword">throws</span> Exception {
  String path = proxy.path(<span class="hljs-string">"/proxy/path/"</span>);
  <span class="hljs-keyword">return</span> proxy.uri(home.toString() + <span class="hljs-string">"/foos/"</span> + path).get();
}
</code><div class="codetools"><button class="copy-button" title="Copy to clipboard" type="button"><span class="label">Copy to clipboard</span><span class="copied"></span></button></div></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring MVC和Webflux的所有功能都可用于网关 handler method。因此，你可以注入请求头和查询参数，例如，你可以通过 mapping 注解中的声明来限制传入的请求。关于这些功能的更多细节，请参见Spring MVC中的 <code>@RequestMapping</code> 文档。</p>
</div>
<div class="paragraph">
<p>你可以通过使用 <code>ProxyExchange</code> 的 <code>header()</code> 方法在下游响应中添加头信息。</p>
</div>
<div class="paragraph">
<p>你也可以通过给 <code>get()</code> 方法（和其他方法）添加一个 mapper 来操作响应头（以及 response 中你喜欢的其他东西）。mapper 是一个 <code>Function</code>，它接收传入的 <code>ResponseEntity</code> 并将其转换为传出的。</p>
</div>
<div class="paragraph">
<p>对 "敏感" header（默认为 <code>cookie</code> 和 授 <code>authorization</code>）和 “proxy”（<code>x-forwarded-*</code>）header 提供了一流的支持，这些标头不会被传递到下游。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aot-和-原生镜像native-image的支持"><a class="anchor" href="#aot-%E5%92%8C-%E5%8E%9F%E7%94%9F%E9%95%9C%E5%83%8Fnative-image%E7%9A%84%E6%94%AF%E6%8C%81"></a><a class="link" href="#aot-%E5%92%8C-%E5%8E%9F%E7%94%9F%E9%95%9C%E5%83%8Fnative-image%E7%9A%84%E6%94%AF%E6%8C%81">19. AOT 和 原生镜像（Native Image）的支持</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>从 <code>4.0.0</code> 开始，Spring Cloud Gateway支持 Spring AOT 转换和原生镜像。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你使用负载均衡路由，你需要明确定义你的 <code>LoadBalancerClient</code> 服务 ID。你可以通过使用 <code>@LoadBalancerClient</code> 注解的 <code>value</code> 或 <code>name</code> 属性或作为  <code>spring.cloud.loadbalancer.eager-load.clients</code> 属性的值来实现。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="配置属性"><a class="anchor" href="#%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7"></a><a class="link" href="#%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7">20. 配置属性</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>要查看所有与Spring Cloud Gateway相关的配置属性列表，请参见 <a href="appendix.html">附录</a>。</p>
</div>
</div>
</div>
</div>
<script src="./Spring Cloud Gateway 中文文档_files/highlight.min.js.下载"></script>
<script>hljs.initHighlighting()</script>
</div>
  </div>
</div>

<a style="
  display:flex;
  align-items: center;
  border-radius:100%;
  justify-content: center;
  position:fixed;
  z-index:9999;
  width:60px;
  height:60px;
  bottom:50px;
  right:35px;
  background:#86b452;
  color:#fff;
  font-size:16px;
  font-weight: bold;
  box-shadow: 0 0 5px rgba(1, 1, 1, .5);
  " href="https://springdoc.cn/docs/">
    主页
  </a></body></html>